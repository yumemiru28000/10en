<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>10円ゲーム（統合完全版：音/坂強化）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; background:#111; color:#eee; font-family: system-ui, sans-serif; height:100%; overflow:hidden; }
    #wrap { display:flex; height:100vh; overflow:hidden; }

    #ui{
      width: 340px;
      padding: 12px;
      box-sizing:border-box;
      border-right: 1px solid #333;
      background:#0b0b0b;
      overflow:auto;
    }
    #ui h1 { font-size: 14px; margin: 0 0 10px; }
    #ui .row { margin: 10px 0; }
    #ui .label { color:#bbb; font-size: 11px; margin-bottom:6px; }
    #ui button{
      background:#333; color:#eee; border:1px solid #555; border-radius:6px;
      padding: 7px 10px; cursor:pointer; font-size: 12px;
    }
    #ui button:hover { background:#444; }
    #ui input[type="number"], #ui input[type="password"], #ui input[type="text"]{
      width: 160px; background:#222; color:#eee; border:1px solid #555; border-radius:6px; padding:6px 8px;
    }
    #hint { color:#9bd; line-height: 1.5; font-size: 12px; }
    #status { white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 11px; color:#cfc; }

    /* レバーUI（プレイヤーでも見える） */
    #leverBox{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 10px;
    }
    #leverTitle{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:8px;
      font-size:12px;
      color:#ffd24a;
    }
    #leverMeta{
      font-size: 11px;
      color: rgba(255,255,255,0.75);
      line-height: 1.35;
      margin-top:8px;
    }
    #leverBadge{
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.25);
      color: rgba(255,255,255,0.85);
      white-space: nowrap;
    }
    #leverBadge.off{
      color: rgba(255,255,255,0.45);
      border-color: rgba(255,255,255,0.10);
    }
    #leverBadge.max{
      color:#fff;
      border-color: rgba(255,0,0,0.45);
      background: rgba(255,0,0,0.15);
      font-weight: 700;
    }

    #pullArea{
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      position: relative;
      overflow:hidden;
      user-select:none;
      touch-action:none;
      cursor: grab;
    }
    #pullArea:active{ cursor: grabbing; }

    #pullFill{
      position:absolute;
      left:0; top:0; bottom:0;
      width:0%;
      background: linear-gradient(90deg, #20ff70, #ffee55, #ff8a22, #ff2a2a);
      opacity: 0.9;
    }
    #pullKnob{
      position:absolute;
      top: 50%;
      transform: translate(-50%,-50%);
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 2px 10px rgba(0,0,0,0.45);
      left: 0%;
    }
    #leverNums{
      margin-top:8px;
      display:flex;
      justify-content:space-between;
      gap:8px;
      font-size:11px;
      color: rgba(255,255,255,0.75);
    }
    .chip{
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      white-space:nowrap;
    }

    /* world */
    #world { flex: 1; position: relative; display:flex; align-items:center; justify-content:center; overflow:hidden; background:#000; }
    #world canvas { display:block; max-width:100%; max-height:100%; width:auto; height:auto; background:#000; }

    /* 運営モードの表示制御 */
    .adminOnly { display:none; }
    body.admin .adminOnly { display:block; }
    .playerOnly { display:block; }
    body.admin .playerOnly { display:block; }
    body:not(.admin) .adminOnly { display:none; }
  </style>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <h1>10円ゲーム</h1>

    <!-- プレイヤー表示（常に） -->
    <div class="row playerOnly" id="leverBox">
      <div id="leverTitle">
        <div>バー（引いて→離す）</div>
        <div id="leverBadge" class="off">OFF</div>
      </div>

      <div id="pullArea">
        <div id="pullFill"></div>
        <div id="pullKnob"></div>
      </div>

      <div id="leverNums">
        <div class="chip" id="powChip">0%</div>
        <div class="chip" id="dirChip">dir:-</div>
      </div>

      <div id="leverMeta">
        対象: コインの近くの黄色（最寄り）<br>
        条件: 接地 & 有効距離内
      </div>
    </div>

    <div class="row playerOnly">
      <div class="label">運営モード（password: 1122）</div>
      <input id="adminPass" type="password" placeholder="1122">
      <button id="adminEnter">決定</button>
      <button id="adminExit" style="display:none;">退出</button>
      <div id="adminMsg" style="margin-top:6px;font-size:11px;color:#aaa;"></div>
    </div>

    <!-- 運営モードのみ -->
    <div class="adminOnly">
      <div class="row" id="hint">
        ・解析: ren.png（黒=地形 / 赤=穴(失敗) / 緑=開始 / 黄=バネ / 青=クリア）<br>
        ・背景: map.png（無い場合はren.pngに自動切替）<br>
        ・通常表示: map + 10円 + 黄色枠のみ<br>
        ・音: s.mp3(失敗) / u.mp3(発射) / b.mp3(強衝突) / t.mp3(生成/リスポーン)
      </div>

      <div class="row">
        <div class="label">コイン半径(px)</div>
        <input id="coinR" type="number" value="32" min="4" max="128">
      </div>

      <div class="row">
        <div class="label">重力（Matter）</div>
        <input id="gravityY" type="number" value="1" step="0.1" min="0" max="5">
      </div>

      <div class="row">
        <div class="label">最大発射速度(maxImpulse) ※内部で1.5倍</div>
        <input id="maxImpulse" type="number" value="18" step="1" min="1" max="200">
      </div>

      <div class="row">
        <div class="label">最大引き距離(maxPull)</div>
        <input id="maxPull" type="number" value="150" step="10" min="40" max="500">
      </div>

      <div class="row">
        <div class="label">レバーが有効になる距離(px)</div>
        <input id="nearDist" type="number" value="180" step="10" min="20" max="800">
      </div>

      <div class="row">
        <div class="label">クールタイム(s)</div>
        <input id="cooldown" type="number" value="0.30" step="0.05" min="0" max="2">
      </div>

      <div class="row">
        <div class="label">坂補助：角度推定範囲(px)</div>
        <input id="slopeProbe" type="number" value="30" step="2" min="6" max="160">
      </div>

      <div class="row">
        <div class="label">坂補助：加速度倍率（※内部でさらに強化）</div>
        <input id="slopeAssist" type="number" value="1.5" step="0.1" min="0" max="10">
      </div>

      <div class="row">
        <div class="label">地形スムージング：回数</div>
        <input id="smoothIters" type="number" value="2" step="1" min="0" max="6">
      </div>

      <div class="row">
        <div class="label">地形スムージング：多数決しきい値</div>
        <input id="smoothThresh" type="number" value="0.58" step="0.01" min="0.5" max="0.9">
      </div>

      <div class="row">
        <div class="label">地形：線分サンプル(step)</div>
        <input id="segStep" type="number" value="6" step="1" min="2" max="20">
      </div>

      <div class="row">
        <button id="reloadBtn">ren.png から再生成</button>
        <button id="respawnBtn">リスポーン</button>
      </div>

      <div class="row">
        <div class="label">状態</div>
        <div id="status">loading...</div>
      </div>
    </div>
  </div>

  <div id="world"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>

<script>
(() => {
  const REN_URL = "ren.png";
  const MAP_URL = "map.png";
  const ADMIN_PASSWORD = "1122";

  // ==== 音（追加）====
  // ブラウザの自動再生制限対策：
  // 最初のユーザー操作（レバー操作/パスワード決定など）で一度だけ Audio を "解錠" する
  const sounds = {
    fail: new Audio("s.mp3"),   // 失敗
    shot: new Audio("u.mp3"),   // 発射
    hit:  new Audio("b.mp3"),   // 強衝突
    spawn:new Audio("t.mp3"),   // 生成/リスポーン
  };
  for (const a of Object.values(sounds)){
    a.preload = "auto";
    a.volume = 0.9;
  }
  let audioUnlocked = false;
  async function unlockAudioOnce(){
    if (audioUnlocked) return;
    audioUnlocked = true;
    // 無音再生で解錠を試みる（失敗してもゲームは続く）
    try{
      const a = sounds.spawn;
      const prevVol = a.volume;
      a.volume = 0;
      a.currentTime = 0;
      await a.play();
      a.pause();
      a.currentTime = 0;
      a.volume = prevVol;
    }catch(e){
      // iOSなどではここで失敗しうる
      console.warn("audio unlock failed:", e);
    }
  }
  function playSound(key){
    const a = sounds[key];
    if (!a) return;
    // 連打でも鳴るように頭出し
    try{
      a.pause();
      a.currentTime = 0;
      a.play().catch(()=>{});
    }catch(e){}
  }

  // ---- 追加：青（クリア）判定 ----
  function classifyPixel(r,g,b,a){
    if (a < 10) return "empty";
    if (r < 40 && g < 40 && b < 40) return "black";
    if (r > 180 && g < 80 && b < 80) return "red";
    if (g > 160 && r < 120 && b < 120) return "green";
    if (r > 180 && g > 180 && b < 120) return "yellow";
    if (b > 180 && r < 100 && g < 140) return "blue";
    return "empty";
  }

  function extractComponents(mask, w, h){
    const visited = new Uint8Array(w*h);
    const comps = [];
    const qx = new Int32Array(w*h);
    const qy = new Int32Array(w*h);
    const idx = (x,y)=>y*w+x;
    const push = (x,y,tail)=>{ qx[tail]=x; qy[tail]=y; return tail+1; };

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = idx(x,y);
        if (!mask[i] || visited[i]) continue;

        let head=0, tail=0;
        tail = push(x,y,tail);
        visited[i]=1;

        let sumX=0, sumY=0, area=0;
        let minX=x, minY=y, maxX=x, maxY=y;

        while(head<tail){
          const cx=qx[head], cy=qy[head]; head++;
          area++;
          sumX += cx; sumY += cy;
          if (cx<minX) minX=cx; if (cy<minY) minY=cy;
          if (cx>maxX) maxX=cx; if (cy>maxY) maxY=cy;

          const n1 = (cx>0)   ? idx(cx-1,cy) : -1;
          const n2 = (cx<w-1) ? idx(cx+1,cy) : -1;
          const n3 = (cy>0)   ? idx(cx,cy-1) : -1;
          const n4 = (cy<h-1) ? idx(cx,cy+1) : -1;

          if (n1>=0 && mask[n1] && !visited[n1]){ visited[n1]=1; tail=push(cx-1,cy,tail); }
          if (n2>=0 && mask[n2] && !visited[n2]){ visited[n2]=1; tail=push(cx+1,cy,tail); }
          if (n3>=0 && mask[n3] && !visited[n3]){ visited[n3]=1; tail=push(cx,cy-1,tail); }
          if (n4>=0 && mask[n4] && !visited[n4]){ visited[n4]=1; tail=push(cx,cy+1,tail); }
        }

        comps.push({
          area,
          centroid: { x: sumX / area, y: sumY / area },
          aabb: { minX, minY, maxX, maxY }
        });
      }
    }
    comps.sort((a,b)=>b.area-a.area);
    return comps;
  }

  // ----- 地形スムージング -----
  function smoothBinaryMask(mask, w, h, iters=2, threshold=0.58){
    let src = mask;
    let dst = new Uint8Array(w*h);
    const idx = (x,y)=>y*w+x;

    for (let iter=0; iter<iters; iter++){
      dst.fill(0);
      for (let y=1; y<h-1; y++){
        for (let x=1; x<w-1; x++){
          let count = 0;
          count += src[idx(x-1,y-1)];
          count += src[idx(x  ,y-1)];
          count += src[idx(x+1,y-1)];
          count += src[idx(x-1,y  )];
          count += src[idx(x  ,y  )];
          count += src[idx(x+1,y  )];
          count += src[idx(x-1,y+1)];
          count += src[idx(x  ,y+1)];
          count += src[idx(x+1,y+1)];
          dst[idx(x,y)] = (count/9 >= threshold) ? 1 : 0;
        }
      }
      for (let x=0;x<w;x++){ dst[idx(x,0)] = src[idx(x,0)]; dst[idx(x,h-1)] = src[idx(x,h-1)]; }
      for (let y=0;y<h;y++){ dst[idx(0,y)] = src[idx(0,y)]; dst[idx(w-1,y)] = src[idx(w-1,y)]; }
      const tmp = src; src = dst; dst = tmp;
    }
    return src;
  }

  function extractBoundaryPoints(blackMask, w, h){
    const pts = [];
    const idx = (x,y)=>y*w+x;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i = idx(x,y);
        if (!blackMask[i]) continue;
        if (!blackMask[idx(x-1,y)] || !blackMask[idx(x+1,y)] || !blackMask[idx(x,y-1)] || !blackMask[idx(x,y+1)]) {
          pts.push({x,y});
        }
      }
    }
    return pts;
  }

  function pointsToSegmentsApproxSmooth(points, sampleStep=6, grid=2){
    const segs = [];
    const snap = (v)=>Math.round(v / grid) * grid;

    const pts = [];
    for (let i=0; i<points.length; i+=sampleStep){
      const p = points[i];
      pts.push({ x: snap(p.x), y: snap(p.y) });
    }

    const maxD2 = (sampleStep*sampleStep*20);
    const minD2 = 4;

    for (let i=0; i<pts.length; i++){
      const p = pts[i];
      let bestJ = -1;
      let bestD2 = Infinity;

      for (let j=i+1; j<Math.min(pts.length, i+220); j++){
        const q = pts[j];
        const dx=q.x-p.x, dy=q.y-p.y;
        const d2=dx*dx+dy*dy;
        if (d2 < minD2) continue;
        if (d2 < bestD2 && d2 < maxD2){
          bestD2 = d2;
          bestJ = j;
        }
      }

      if (bestJ >= 0){
        const q = pts[bestJ];
        segs.push({x1:p.x,y1:p.y,x2:q.x,y2:q.y});
      }
    }
    return segs;
  }

  function segmentToBody(Matter, seg, thickness=6, opt={}){
    const { Bodies } = Matter;
    const x1=seg.x1, y1=seg.y1, x2=seg.x2, y2=seg.y2;
    const mx=(x1+x2)/2, my=(y1+y2)/2;
    const dx=x2-x1, dy=y2-y1;
    const len=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx);
    return Bodies.rectangle(mx, my, len, thickness, {
      isStatic:true,
      friction: 0.55,
      restitution: 0,
      angle: ang,
      ...opt
    });
  }

  // ---- DOM ----
  const elWorld = document.getElementById("world");
  const statusEl = document.getElementById("status");
  const reloadBtn = document.getElementById("reloadBtn");
  const respawnBtn = document.getElementById("respawnBtn");

  const pullArea = document.getElementById("pullArea");
  const pullFill = document.getElementById("pullFill");
  const pullKnob = document.getElementById("pullKnob");
  const leverBadge = document.getElementById("leverBadge");
  const powChip = document.getElementById("powChip");
  const dirChip = document.getElementById("dirChip");

  const adminPass = document.getElementById("adminPass");
  const adminEnter = document.getElementById("adminEnter");
  const adminExit = document.getElementById("adminExit");
  const adminMsg = document.getElementById("adminMsg");

  const getNum = (id, fallback) => {
    const el = document.getElementById(id);
    if (!el) return fallback;
    const v = parseFloat(el.value);
    return Number.isFinite(v) ? v : fallback;
  };

  // ---- Matter ----
  const Matter = window.Matter;
  const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

  let engine, render, runner;
  let renCanvas, renCtx, renData;
  let mapW=0, mapH=0;

  let coin=null;
  let spawnPoint={x:100,y:100};

  let holes=[];
  let goals=[];
  let springs=[];

  let touchingGround = false;
  let lastGroundNormal = null;
  let blackMaskGlobal = null;

  // レバー状態
  let lever = {
    enabled: false,
    activeSpring: null,
    dragging: false,
    pointerId: null,
    startX: 0,
    currentX: 0,
    pullRatio: 0
  };

  // 結果表示
  let lastResultAt = 0;
  function showResultOncePerSec(msg){
    const now = performance.now();
    if (now - lastResultAt < 900) return;
    lastResultAt = now;
    alert(msg);
  }

  // ---- admin mode ----
  function setAdminMode(on){
    document.body.classList.toggle("admin", !!on);
    adminExit.style.display = on ? "inline-block" : "none";
  }
  setAdminMode(false);

  adminEnter.addEventListener("click", async () => {
    await unlockAudioOnce();
    if (adminPass.value === ADMIN_PASSWORD){
      setAdminMode(true);
      adminMsg.textContent = "運営モードON";
      adminPass.value = "";
    } else {
      adminMsg.textContent = "パスワードが違います";
    }
  });
  adminExit.addEventListener("click", async () => {
    await unlockAudioOnce();
    setAdminMode(false);
    adminMsg.textContent = "運営モードOFF";
  });

  function setStatus(lines){
    if (!statusEl) return;
    statusEl.textContent = lines.join("\n");
  }

  function destroyWorld(){
    if (render) {
      Render.stop(render);
      render.canvas.remove();
      render.textures = {};
      render = null;
    }
    if (runner) { Runner.stop(runner); runner=null; }
    if (engine) { World.clear(engine.world, false); Engine.clear(engine); engine=null; }

    holes=[]; goals=[]; springs=[];
    coin=null;
    lever.enabled=false; lever.activeSpring=null; lever.dragging=false; lever.pullRatio=0;
    blackMaskGlobal = null;
    window.removeEventListener("resize", resizeCanvasToFit);
  }

  async function loadImage(url){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = url + "?t=" + Date.now();
    });
  }

  function buildRenImageData(img){
    mapW = img.naturalWidth || img.width;
    mapH = img.naturalHeight || img.height;

    renCanvas = document.createElement("canvas");
    renCanvas.width = mapW;
    renCanvas.height = mapH;
    renCtx = renCanvas.getContext("2d", { willReadFrequently:true });
    renCtx.drawImage(img, 0, 0);
    renData = renCtx.getImageData(0,0,mapW,mapH);
  }

  function buildMasks(){
    const w=mapW, h=mapH;
    const data=renData.data;
    const black = new Uint8Array(w*h);
    const red   = new Uint8Array(w*h);
    const green = new Uint8Array(w*h);
    const yellow= new Uint8Array(w*h);
    const blue  = new Uint8Array(w*h);

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = (y*w+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        const c = classifyPixel(r,g,b,a);
        const p = y*w+x;
        if (c==="black") black[p]=1;
        else if (c==="red") red[p]=1;
        else if (c==="green") green[p]=1;
        else if (c==="yellow") yellow[p]=1;
        else if (c==="blue") blue[p]=1;
      }
    }
    return {black, red, green, yellow, blue};
  }

  function createEngineAndRenderer(){
    engine = Engine.create();
    engine.gravity.y = getNum("gravityY", 1);

    render = Render.create({
      element: elWorld,
      engine,
      options: {
        width: mapW,
        height: mapH,
        wireframes: false,
        background: "#000",
        hasBounds: false,
        pixelRatio: window.devicePixelRatio || 1
      }
    });

    runner = Runner.create();
    Render.run(render);
    Runner.run(runner, engine);

    requestAnimationFrame(resizeCanvasToFit);
    window.addEventListener("resize", resizeCanvasToFit);
  }

  function setBackground(url){
    render.options.background = `url(${url})`;
    render.canvas.style.backgroundImage = `url(${url})`;
    render.canvas.style.backgroundSize = "100% 100%";
    render.canvas.style.backgroundRepeat = "no-repeat";
    render.canvas.style.backgroundPosition = "0 0";
  }

  function resizeCanvasToFit(){
    if (!render) return;
    const canvas = render.canvas;
    const worldRect = elWorld.getBoundingClientRect();
    const scale = Math.min(worldRect.width / mapW, worldRect.height / mapH);
    canvas.style.width  = (mapW * scale) + "px";
    canvas.style.height = (mapH * scale) + "px";
  }

  function addCoin(){
    const r = getNum("coinR", 32);

    coin = Bodies.circle(spawnPoint.x, spawnPoint.y, r, {
      restitution: 0,
      friction: 0.015,      // さらに止まりにくく
      frictionStatic: 0.20, // 静止摩擦をもっと弱める
      frictionAir: 0.008,
      density: 0.005,
      render: { fillStyle: "#b87333", strokeStyle: "#5b2a12", lineWidth: 2 }
    });

    World.add(engine.world, coin);
    playSound("spawn"); // 生成音 t.mp3
  }

  function respawn(){
    if (!coin) return;
    Body.setPosition(coin, {x:spawnPoint.x, y:spawnPoint.y});
    Body.setVelocity(coin, {x:0, y:0});
    Body.setAngularVelocity(coin, 0);
    playSound("spawn"); // リスポーン音 t.mp3
  }

  function addHolesFromComponents(redComps){
    holes = [];
    for (const c of redComps){
      let r = Math.sqrt(c.area / Math.PI);
      r = Math.max(12, Math.min(90, r));
      const hole = Bodies.circle(c.centroid.x, c.centroid.y, r, {
        isStatic: true,
        isSensor: true,
        render: { visible: false }
      });
      hole.label = "hole";
      holes.push(hole);
    }
    World.add(engine.world, holes);
  }

  function addGoalsFromComponents(blueComps){
    goals = [];
    for (const c of blueComps){
      let r = Math.sqrt(c.area / Math.PI);
      r = Math.max(14, Math.min(110, r));
      const goal = Bodies.circle(c.centroid.x, c.centroid.y, r, {
        isStatic: true,
        isSensor: true,
        render: { visible: false }
      });
      goal.label = "goal";
      goals.push(goal);
    }
    World.add(engine.world, goals);
  }

  function addSpringsFromComponents(yellowComps){
    springs = [];
    const centerX = mapW / 2;
    const picked = yellowComps.slice(0, 6);

    for (const c of picked){
      const dir = (c.centroid.x < centerX) ? +1 : -1;
      const pad = 8;
      const aabb = {
        minX: c.aabb.minX - pad,
        minY: c.aabb.minY - pad,
        maxX: c.aabb.maxX + pad,
        maxY: c.aabb.maxY + pad,
      };

      const sensor = Bodies.rectangle(
        (aabb.minX+aabb.maxX)/2,
        (aabb.minY+aabb.maxY)/2,
        Math.max(10, aabb.maxX-aabb.minX),
        Math.max(10, aabb.maxY-aabb.minY),
        { isStatic:true, isSensor:true, render:{ visible:false } }
      );
      sensor.label = "springSensor";

      springs.push({ sensor, center:{x:c.centroid.x,y:c.centroid.y}, dir, cooldownUntil:0, aabb });
    }
    World.add(engine.world, springs.map(s=>s.sensor));
  }

  function addTerrainFromBlack(blackMask){
    const iters = Math.max(0, Math.min(6, Math.round(getNum("smoothIters", 2))));
    const thresh = Math.max(0.5, Math.min(0.9, getNum("smoothThresh", 0.58)));
    const smooth = (iters > 0) ? smoothBinaryMask(blackMask, mapW, mapH, iters, thresh) : blackMask;

    blackMaskGlobal = smooth;

    const boundaryPts = extractBoundaryPoints(smooth, mapW, mapH);
    const step = Math.max(2, Math.min(20, Math.round(getNum("segStep", 6))));
    const segs = pointsToSegmentsApproxSmooth(boundaryPts, step, 2);

    const bodies = [];
    for (const seg of segs){
      const b = segmentToBody(Matter, seg, 6, { render: { visible: false } });
      b.label = "terrain";
      bodies.push(b);
    }
    World.add(engine.world, bodies);

    return { boundaryPtsCount: boundaryPts.length, segCount: segs.length };
  }

  function nowSec(){ return performance.now()/1000; }

  function coinInsideSpring(s){
    const p = coin.position;
    const a = s.aabb;
    return (p.x >= a.minX && p.x <= a.maxX && p.y >= a.minY && p.y <= a.maxY);
  }

  function nearestSpringByDistance(){
    const nearDist = Math.max(0, getNum("nearDist", 180));
    let best=null, bestD2=Infinity;

    for (const s of springs){
      const dx = coin.position.x - s.center.x;
      const dy = coin.position.y - s.center.y;
      const d2 = dx*dx + dy*dy;

      const near = coinInsideSpring(s) || (d2 <= nearDist*nearDist);
      if (!near) continue;

      if (d2 < bestD2){
        bestD2 = d2;
        best = s;
      }
    }
    return best;
  }

  function setLeverUI(enabled, pullRatio, spring){
    lever.enabled = enabled;
    lever.activeSpring = spring;

    const pct = Math.round(pullRatio * 100);
    pullFill.style.width = pct + "%";
    pullKnob.style.left = pct + "%";
    powChip.textContent = pct + "%";

    if (!enabled){
      leverBadge.textContent = "OFF";
      leverBadge.classList.add("off");
      leverBadge.classList.remove("max");
      dirChip.textContent = "dir:-";
      pullArea.style.opacity = "0.45";
      return;
    }

    pullArea.style.opacity = "1";
    leverBadge.classList.remove("off");
    dirChip.textContent = spring ? (spring.dir > 0 ? "dir:→(右)" : "dir:←(左)") : "dir:-";

    const isMax = pullRatio >= 0.98;
    if (isMax){
      leverBadge.textContent = "MAX";
      leverBadge.classList.add("max");
    } else {
      leverBadge.textContent = lever.dragging ? "CHARGING" : "READY";
      leverBadge.classList.remove("max");
    }
  }

  function canOperateLever(s){
    if (!s) return false;
    const now = nowSec();
    if (now < s.cooldownUntil) return false;
    if (!touchingGround) return false;
    return true;
  }

  // ---- 上向きゼロ固定 / 発射力1.5倍 ----
  const UPWARD_BIAS_FIXED = 0;
  const IMPULSE_MULT = 1.5;

  function launchFromSpring(s, pullRatio){
    const now = nowSec();
    if (now < s.cooldownUntil) return;
    if (!touchingGround) return;

    const maxImpulse = getNum("maxImpulse", 18);
    const cooldown = Math.max(0, getNum("cooldown", 0.30));

    const impulse = (maxImpulse * IMPULSE_MULT) * Math.max(0, Math.min(1, pullRatio));

    Body.setVelocity(coin, { x: s.dir * impulse, y: -impulse * UPWARD_BIAS_FIXED });
    Body.setAngularVelocity(coin, 0);

    s.cooldownUntil = now + cooldown;

    // 発射音 u.mp3
    playSound("shot");
  }

  // ---- レバー入力 ----
  pullArea.addEventListener("pointerdown", async (e) => {
    await unlockAudioOnce();
    if (!coin) return;
    if (!lever.enabled) return;
    if (!canOperateLever(lever.activeSpring)) return;

    lever.dragging = true;
    lever.pointerId = e.pointerId;
    lever.startX = e.clientX;
    lever.currentX = e.clientX;
    pullArea.setPointerCapture(e.pointerId);
  });

  pullArea.addEventListener("pointermove", (e) => {
    if (!lever.dragging) return;
    if (lever.pointerId !== e.pointerId) return;
    lever.currentX = e.clientX;

    const s = lever.activeSpring;
    if (!s) return;

    const maxPull = Math.max(10, getNum("maxPull", 150));
    const dx = lever.currentX - lever.startX;

    const pullSigned = -s.dir * dx;
    const pullPx = Math.max(0, Math.min(maxPull, pullSigned));
    lever.pullRatio = Math.max(0, Math.min(1, pullPx / maxPull));

    setLeverUI(true, lever.pullRatio, s);
  });

  function releasePointer(e){
    if (!lever.dragging) return;
    if (lever.pointerId !== e.pointerId) return;

    lever.dragging = false;

    const s = lever.activeSpring;
    const ratio = lever.pullRatio;

    if (s && ratio > 0 && canOperateLever(s)){
      launchFromSpring(s, ratio);
    }

    lever.pullRatio = 0;
    setLeverUI(lever.enabled, 0, lever.activeSpring);
  }

  pullArea.addEventListener("pointerup", releasePointer);
  pullArea.addEventListener("pointercancel", releasePointer);

  // ---- 坂���助（さらに強化）----
  // 要望: 斜面で詰まる→「加速度をもっと上げる」
  // 対策:
  // 1) 加速度倍率を増やす（定数）
  // 2) 低速時だけ強く押す（詰まり救済）
  // 3) 小さい斜面(sin小)は無視しないよう閾値を下げる
  const SLOPE_ACCEL_MULT = 2.0;     // 既存要望の2倍
  const SLOPE_EXTRA_MULT = 2.2;     // さらに上乗せ（今回追加）
  const STUCK_BOOST_MULT = 3.0;     // 低速のとき追加
  const STUCK_SPEED_TH = 0.20;      // これ未満は詰まり扱い
  const MIN_SIN_TO_APPLY = 0.02;    // 小さな斜面でも動かす

  function isBlackAt(x,y){
    if (!blackMaskGlobal) return false;
    x = Math.max(0, Math.min(mapW-1, x|0));
    y = Math.max(0, Math.min(mapH-1, y|0));
    return blackMaskGlobal[y*mapW + x] === 1;
  }

  function findGroundY(x, startY, maxDown=80){
    const sx = x|0;
    let y = Math.max(0, Math.min(mapH-1, startY|0));
    for (let i=0;i<maxDown;i++){
      const yy = y + i;
      if (yy >= mapH) break;
      if (isBlackAt(sx, yy) && !isBlackAt(sx, yy-1)) return yy;
    }
    return null;
  }

  function estimateSlopeAtCoin(){
    if (!coin) return null;

    const probe = Math.max(6, getNum("slopeProbe", 30));
    const px = coin.position.x;
    const py = coin.position.y;

    const r = getNum("coinR", 32);
    const startY = py + r * 0.6;

    const xL = Math.max(0, Math.min(mapW-1, (px - probe)|0));
    const xR = Math.max(0, Math.min(mapW-1, (px + probe)|0));

    const yL = findGroundY(xL, startY, 140);
    const yR = findGroundY(xR, startY, 140);
    if (yL == null || yR == null) return null;

    const dx = (xR - xL);
    if (dx <= 0) return null;

    const dy = (yR - yL);
    const slope = dy / dx;
    return { slope };
  }

  function applySlopeAssist(){
    if (!coin) return;
    if (!touchingGround) return;

    const est = estimateSlopeAtCoin();
    if (!est) return;

    const tan = est.slope;
    const sin = tan / Math.sqrt(1 + tan*tan);

    if (Math.abs(sin) < MIN_SIN_TO_APPLY) return;

    const gMatter = engine.gravity.y;
    const assistUI = getNum("slopeAssist", 1.5);

    // 基本加速度
    let assistK = assistUI * SLOPE_ACCEL_MULT * SLOPE_EXTRA_MULT;

    // 詰まり救済：ほぼ止まってたらさらに押す
    const speed = Math.hypot(coin.velocity.x, coin.velocity.y);
    if (speed < STUCK_SPEED_TH) assistK *= STUCK_BOOST_MULT;

    const ax = gMatter * sin * assistK;
    const dt = 0.016;

    const v = coin.velocity;
    const newVx = v.x + ax * dt;

    // 下り方向の最低速度を保証（詰まり除去）
    const downhillDir = (sin > 0) ? +1 : -1;
    const minRoll = (speed < STUCK_SPEED_TH) ? 0.20 : 0.10;

    let vx = newVx;
    if (Math.sign(vx) === downhillDir && Math.abs(vx) < minRoll){
      vx = downhillDir * minRoll;
    }

    Body.setVelocity(coin, { x: vx, y: v.y });
  }

  // ---- マスク作成 ----
  function buildMasksFromRen(){
    const {black, red, green, yellow, blue} = buildMasks();

    const greenComps = extractComponents(green, mapW, mapH);
    const redComps = extractComponents(red, mapW, mapH);
    const yellowComps = extractComponents(yellow, mapW, mapH);
    const blueComps = extractComponents(blue, mapW, mapH);

    spawnPoint = (greenComps.length ? greenComps[0].centroid : {x:100,y:100});

    const terrainInfo = addTerrainFromBlack(black);
    addHolesFromComponents(redComps);
    addGoalsFromComponents(blueComps);
    addSpringsFromComponents(yellowComps);

    return { terrainInfo, redCount:redComps.length, yellowCount:yellowComps.length, blueCount:blueComps.length };
  }

  // ---- 表示制限 ----
  function isAdminMode(){
    return document.body.classList.contains("admin");
  }

  function drawYellowFrames(){
    if (!render || !coin) return;
    const ctx = render.context;

    for (const s of springs){
      const active = (s === lever.activeSpring);

      ctx.save();
      ctx.strokeStyle = active ? "rgba(255,220,80,0.95)" : "rgba(255,255,0,0.55)";
      ctx.lineWidth = active ? 4 : 3;

      const a = s.aabb;
      ctx.strokeRect(a.minX, a.minY, a.maxX-a.minX, a.maxY-a.minY);

      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = active ? "rgba(255,220,80,0.95)" : "rgba(255,255,0,0.7)";
      ctx.fillText(s.dir > 0 ? "→" : "←", s.center.x, s.center.y - 22);

      ctx.restore();
    }
  }

  function drawAdminOverlays(){
    if (!render) return;
    const ctx = render.context;

    ctx.save();
    for (const h of holes){
      ctx.beginPath();
      ctx.arc(h.position.x, h.position.y, h.circleRadius, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,0,0,0.18)";
      ctx.fill();
      ctx.strokeStyle = "rgba(255,0,0,0.6)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    for (const g of goals){
      ctx.beginPath();
      ctx.arc(g.position.x, g.position.y, g.circleRadius, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,160,255,0.18)";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,160,255,0.7)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  // ---- 強衝突音 b.mp3 ----
  // collisionStartで coin- terrain の衝突強度を推定して鳴らす
  let lastHitAt = 0;
  const HIT_COOLDOWN_MS = 120;
  const HIT_SPEED_TH = 7.5; // これ以上の相対速度で「勢いよくぶつかった」
  function handleHitSound(ev){
    if (!coin) return;
    const now = performance.now();
    if (now - lastHitAt < HIT_COOLDOWN_MS) return;

    for (const pair of ev.pairs){
      const a = pair.bodyA, b = pair.bodyB;
      const coinHit = (a === coin || b === coin);
      if (!coinHit) continue;

      // terrain か壁相当だけを対象（hole/goal/sensorは除外）
      const other = (a === coin) ? b : a;
      if (other.label !== "terrain") continue;

      // 相対速度の概算
      const v1 = coin.velocity;
      const v2 = other.velocity || {x:0,y:0};
      const rel = Math.hypot(v1.x - v2.x, v1.y - v2.y);

      if (rel >= HIT_SPEED_TH){
        lastHitAt = now;
        playSound("hit");
        break;
      }
    }
  }

  function installEvents(){
    Events.on(engine, "collisionStart", (ev) => {
      handleHitSound(ev);
    });

    Events.on(engine, "collisionActive", (ev) => {
      touchingGround = false;
      lastGroundNormal = null;

      for (const pair of ev.pairs){
        const a = pair.bodyA, b = pair.bodyB;

        if ((a === coin && b.label==="hole") || (b === coin && a.label==="hole")){
          respawn();
          playSound("fail");              // 失敗音 s.mp3
          showResultOncePerSec("失敗！");
          continue;
        }

        if ((a === coin && b.label==="goal") || (b === coin && a.label==="goal")){
          respawn();
          // クリア音が指定されてないので今回は無し（必要なら追加可能）
          showResultOncePerSec("クリア！");
          continue;
        }

        const isTerrainContact =
          (a === coin && b.label==="terrain") || (b === coin && a.label==="terrain");
        if (isTerrainContact){
          touchingGround = true;
          lastGroundNormal = pair.collision.normal;
        }
      }
    });

    Events.on(engine, "afterUpdate", () => {
      if (!coin) return;

      const s = nearestSpringByDistance();
      const enabled = !!s && canOperateLever(s);

      if (!lever.dragging){
        lever.activeSpring = s;
        lever.enabled = enabled;
      } else {
        if (!lever.activeSpring || !canOperateLever(lever.activeSpring)){
          lever.dragging = false;
          lever.pullRatio = 0;
          lever.enabled = false;
          lever.activeSpring = null;
        }
      }
      setLeverUI(lever.enabled, lever.pullRatio, lever.activeSpring);

      applySlopeAssist();

      setStatus([
        `map: ${mapW}x${mapH}`,
        `coin: speed=${coin.speed.toFixed(2)} angVel=${coin.angularVelocity.toFixed(3)}`,
        `touchingGround: ${touchingGround}`,
        `springs=${springs.length} holes=${holes.length} goals=${goals.length}`,
        `impulse: base=${getNum("maxImpulse",18)} x${IMPULSE_MULT} upwardBias=${UPWARD_BIAS_FIXED}`,
        `slope: probe=${getNum("slopeProbe",30)} ui=${getNum("slopeAssist",1.5)} x(${SLOPE_ACCEL_MULT}*${SLOPE_EXTRA_MULT}) + stuckBoost`,
        `hitSound: relSpeed>=${HIT_SPEED_TH}`
      ]);

      // 平坦だけ停止（詰まり防止のため、より限定）
      if (!touchingGround || !lastGroundNormal) return;
      const n = lastGroundNormal;
      const v = coin.velocity;
      const slopeMeasure = Math.abs(n.x);

      if (Math.abs(v.x) < 0.04 && Math.abs(coin.angularVelocity) < 0.015 && slopeMeasure < 0.06){
        Body.setVelocity(coin, { x: 0, y: v.y });
        Body.setAngularVelocity(coin, 0);
      }
    });

    Events.on(render, "afterRender", () => {
      drawYellowFrames();
      if (isAdminMode()) drawAdminOverlays();
    });
  }

  async function rebuild(){
    destroyWorld();
    setStatus(["loading ren.png / map.png ..."]);

    const renImg = await loadImage(REN_URL);
    buildRenImageData(renImg);

    let bgOk = true;
    try { await loadImage(MAP_URL); } catch(e){ bgOk = false; console.warn("map.png load failed", e); }

    createEngineAndRenderer();
    setBackground(bgOk ? MAP_URL : REN_URL);

    const {black, red, green, yellow, blue} = buildMasks();

    // spawn
    const greenComps = extractComponents(green, mapW, mapH);
    spawnPoint = (greenComps.length ? greenComps[0].centroid : {x:100,y:100});

    // terrain (smooth)
    const iters = Math.max(0, Math.min(6, Math.round(getNum("smoothIters", 2))));
    const thresh = Math.max(0.5, Math.min(0.9, getNum("smoothThresh", 0.58)));
    const smooth = (iters > 0) ? smoothBinaryMask(black, mapW, mapH, iters, thresh) : black;
    blackMaskGlobal = smooth;

    const boundaryPts = extractBoundaryPoints(smooth, mapW, mapH);
    const step = Math.max(2, Math.min(20, Math.round(getNum("segStep", 6))));
    const segs = pointsToSegmentsApproxSmooth(boundaryPts, step, 2);

    const bodies = [];
    for (const seg of segs){
      const b = segmentToBody(Matter, seg, 6, { render: { visible: false } });
      b.label = "terrain";
      bodies.push(b);
    }
    World.add(engine.world, bodies);

    // sensors
    const redComps = extractComponents(red, mapW, mapH);
    const yellowComps = extractComponents(yellow, mapW, mapH);
    const blueComps = extractComponents(blue, mapW, mapH);

    addHolesFromComponents(redComps);
    addGoalsFromComponents(blueComps);
    addSpringsFromComponents(yellowComps);

    addCoin();
    installEvents();

    setStatus([
      `ready`,
      `terrain segs=${segs.length} smoothIters=${iters} thresh=${thresh}`,
      `red=${redComps.length} yellow=${Math.min(6, yellowComps.length)} blue=${blueComps.length}`
    ]);
  }

  if (reloadBtn) reloadBtn.addEventListener("click", async () => { await unlockAudioOnce(); rebuild(); });
  if (respawnBtn) respawnBtn.addEventListener("click", async () => { await unlockAudioOnce(); respawn(); });

  rebuild().catch(err => {
    console.error(err);
    setStatus(["ERROR:", String(err)]);
  });
})();
</script>
</body>
</html>
