<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>10円ゲーム（マルチ）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#111;
      --panel:#0b0b0b;
      --border:#333;
      --text:#eee;
      --muted:#bbb;
      --accent:#ffd24a;
      --ok:#20ff70;
      --warn:#ff8a22;
      --bad:#ff2a2a;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui, sans-serif; overflow:hidden;}
    button,input{font-family:inherit}

    /* 見やすさ：左パネルを少し狭くし、右を広く */
    #app{height:100vh; display:grid; grid-template-columns: 320px 1fr;}

    #ui{
      padding: 12px;
      box-sizing:border-box;
      border-right:1px solid var(--border);
      background:var(--panel);
      overflow:auto;
    }
    #world{
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      position:relative;
      min-width: 0;
    }
    #world canvas{
      display:block;
      max-width:100%;
      max-height:100%;
      width:auto;
      height:auto;
      background-color:#000;
      background-repeat:no-repeat;
      background-position:0 0;
      background-size:100% 100%;
    }

    .card{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 12px;
      margin: 10px 0;
    }
    .title{font-size:14px; margin:0 0 8px;}
    .label{font-size:11px; color:var(--muted); margin-bottom:6px;}
    .row{margin:10px 0;}
    .btn{
      background:#333; color:#eee; border:1px solid #555; border-radius:8px;
      padding: 8px 10px; cursor:pointer; font-size: 12px;
    }
    .btn:hover{background:#444;}
    .btn.ok{background:#163; border-color:#2a6;}
    .btn.bad{background:#511; border-color:#a33;}
    .btn:disabled{opacity:0.45; cursor:not-allowed;}
    input[type="text"], input[type="password"], input[type="number"]{
      width:100%;
      box-sizing:border-box;
      background:#222; color:#eee; border:1px solid #555; border-radius:8px; padding:8px 10px;
    }

    #status{
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      color:#cfc;
    }

    /* レバー */
    #leverHead{display:flex; justify-content:space-between; align-items:center; gap:10px;}
    #leverBadge{
      font-size: 11px;
      padding: 2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.25);
      color: rgba(255,255,255,0.85);
      white-space:nowrap;
    }
    #leverBadge.off{opacity:0.6;}
    #pullArea{
      margin-top:10px;
      height:44px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      position:relative;
      overflow:hidden;
      user-select:none;
      touch-action:none;
      cursor:grab;
    }
    #pullArea:active{cursor:grabbing;}
    #pullFill{position:absolute; left:0; top:0; bottom:0; width:0%; background: linear-gradient(90deg, var(--ok), #ffee55, var(--warn), var(--bad)); opacity:0.9;}
    #pullKnob{position:absolute; top:50%; transform:translate(-50%,-50%); width:18px; height:18px; border-radius:999px; background: rgba(255,255,255,0.92); box-shadow: 0 2px 10px rgba(0,0,0,0.45); left:0%;}
    #leverNums{margin-top:8px; display:flex; justify-content:space-between; gap:8px; font-size:11px; color: rgba(255,255,255,0.75);}
    .chip{padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); white-space:nowrap;}

    /* クリア演出（自分だけ） */
    #clearOverlay{
      position:absolute; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.65);
      z-index: 5;
    }
    #clearOverlay img{
      max-width: 80%;
      max-height: 80%;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 10px 40px rgba(0,0,0,0.7);
      background:#000;
    }

    body:not(.admin) .adminOnly{display:none;}
    body.admin .adminOnly{display:block;}
  </style>
</head>
<body>
<div id="app">
  <div id="ui">
    <!-- 画面：ゲーム選択 -->
    <div id="screenSelect" class="card">
      <h2 class="title">ゲーム選択</h2>
      <div class="row">
        <button id="btnSelectCoin" class="btn ok">10円ゲーム</button>
      </div>
      <div class="row">
        <button id="btnSelectJanken" class="btn">じゃんけん（準備中）</button>
      </div>
      <div id="selectMsg" style="font-size:11px;color:#aaa;"></div>
    </div>

    <!-- 画面：名前入力 -->
    <div id="screenName" class="card" style="display:none;">
      <h2 class="title">名前入力</h2>
      <div class="label">空なら「匿名」</div>
      <input id="nameInput" type="text" placeholder="名前">
      <div class="row" style="display:flex; gap:8px;">
        <button id="btnNameBack" class="btn">戻る</button>
        <button id="btnNameOk" class="btn ok">決定</button>
      </div>
    </div>

    <!-- 画面：10円ゲーム -->
    <div id="screenCoin" style="display:none;">
      <div class="card">
        <h2 class="title">10円ゲーム（マルチ）</h2>
        <div class="row">
          <div class="label">あなた</div>
          <div id="meLine" style="font-size:12px;"></div>
        </div>
        <div class="row">
          <div class="label">現在プレイ中</div>
          <div id="currentPlayerLine" style="font-size:12px;color:var(--accent);">-</div>
        </div>

        <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
          <button id="btnPlay" class="btn ok">プレイ開始</button>
          <button id="btnEnd" class="btn bad" disabled>終了</button>
          <button id="btnResetCoin" class="btn" disabled>10円リセット</button>
          <button id="btnRespawn" class="btn" disabled>戻る（新規生成）</button>
        </div>

        <div class="row">
          <button id="btnWait" class="btn">待機</button>
          <div id="waitLine" style="margin-top:6px;font-size:11px;color:#aaa;"></div>
        </div>
      </div>

      <div class="card">
        <div id="leverHead">
          <div style="color:var(--accent); font-size:12px;">バー（引いて→離す）</div>
          <div id="leverBadge" class="off">OFF</div>
        </div>
        <div id="pullArea">
          <div id="pullFill"></div>
          <div id="pullKnob"></div>
        </div>
        <div id="leverNums">
          <div class="chip" id="powChip">0%</div>
          <div class="chip" id="dirChip">dir:-</div>
        </div>
        <div style="margin-top:8px; font-size:11px; color:rgba(255,255,255,0.75); line-height:1.35;">
          操作できるのはプレイヤーのみ
        </div>
      </div>

      <div class="card">
        <div class="label">運営モード（password:1122）</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <input id="adminPass" type="password" placeholder="1122" style="flex:1;">
          <button id="adminEnter" class="btn">決定</button>
          <button id="adminExit" class="btn" style="display:none;">退出</button>
        </div>
        <div id="adminMsg" style="margin-top:6px;font-size:11px;color:#aaa;"></div>

        <div class="adminOnly" style="margin-top:10px;">
          <div class="label">（運営のみ）背景デバッグ</div>
          <div id="bgDebug" style="font-size:11px;color:#9bd;">-</div>

          <div class="label" style="margin-top:10px;">（運営のみ）再生成</div>
          <button id="btnReload" class="btn">ren.pngから再生成</button>
        </div>
      </div>

      <div class="card adminOnly">
        <div class="label">状態（運営のみ）</div>
        <div id="status">-</div>
      </div>
    </div>
  </div>

  <div id="world">
    <div id="clearOverlay"><img src="krg.png" alt="clear"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>

<script type="module">
  // ==========================
  // Firebase 初期化（あなたのスニペット準拠）
  // ==========================
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-analytics.js";
  import {
    getDatabase,
    ref,
    onValue,
    set,
    update,
    serverTimestamp,
    runTransaction,
    onDisconnect,
  } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCC7KAv7V4j1Z6-o1Y8ikmb3r5htN9O_aA",
    authDomain: "zzgohan-280.firebaseapp.com",
    databaseURL: "https://zzgohan-280-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "zzgohan-280",
    storageBucket: "zzgohan-280.firebasestorage.app",
    messagingSenderId: "459336048542",
    appId: "1:459336048542:web:ff6c825dec81cc7df8008f",
    measurementId: "G-JX4RP9LWR3"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const db = getDatabase(app);

  // ==========================
  // 設定（ファイル名）
  // ==========================
  const REN_URL = "ren.png";
  const MAP_URL = "map.png";
  const COIN_IMG_URL = "10.png";
  const SND_FAIL = "s.mp3";
  const SND_SHOT = "u.mp3";
  const SND_HIT  = "b.mp3";
  const SND_SPAWN= "t.mp3";
  const SND_CLEAR= "kr.mp3";

  // ==========================
  // RTDB パス
  // ==========================
  const ROOM = "rooms/default";
  const rRoom = (p)=>ref(db, `${ROOM}/${p}`);
  const rLock  = rRoom("lock");
  const rWait  = rRoom("waiters");
  const rEvent = rRoom("event");
  const rSnap  = rRoom("snapshot");

  // ==========================
  // UI
  // ==========================
  const $ = (id)=>document.getElementById(id);

  const screenSelect = $("screenSelect");
  const screenName = $("screenName");
  const screenCoin = $("screenCoin");

  const btnSelectCoin = $("btnSelectCoin");
  const btnSelectJanken = $("btnSelectJanken");
  const selectMsg = $("selectMsg");

  const nameInput = $("nameInput");
  const btnNameBack = $("btnNameBack");
  const btnNameOk = $("btnNameOk");

  const meLine = $("meLine");
  const currentPlayerLine = $("currentPlayerLine");
  const btnPlay = $("btnPlay");
  const btnEnd = $("btnEnd");
  const btnResetCoin = $("btnResetCoin");
  const btnRespawn = $("btnRespawn");
  const btnWait = $("btnWait");
  const waitLine = $("waitLine");

  const pullArea = $("pullArea");
  const pullFill = $("pullFill");
  const pullKnob = $("pullKnob");
  const leverBadge = $("leverBadge");
  const powChip = $("powChip");
  const dirChip = $("dirChip");

  const clearOverlay = $("clearOverlay");

  const adminPass = $("adminPass");
  const adminEnter = $("adminEnter");
  const adminExit = $("adminExit");
  const adminMsg = $("adminMsg");
  const btnReload = $("btnReload");
  const bgDebug = $("bgDebug");
  const statusEl = $("status");

  // ==========================
  // 状態
  // ==========================
  let myName = "";
  let myId = crypto.randomUUID();

  let isAdmin=false;
  function setAdminMode(on){
    isAdmin=!!on;
    document.body.classList.toggle("admin", isAdmin);
    adminExit.style.display = isAdmin ? "inline-block" : "none";
  }
  setAdminMode(false);

  function showScreen(which){
    screenSelect.style.display = (which==="select") ? "block" : "none";
    screenName.style.display = (which==="name") ? "block" : "none";
    screenCoin.style.display = (which==="coin") ? "block" : "none";
  }

  // ==========================
  // 音
  // ==========================
  const sounds = {
    fail: new Audio(SND_FAIL),
    shot: new Audio(SND_SHOT),
    hit:  new Audio(SND_HIT),
    spawn:new Audio(SND_SPAWN),
    clear:new Audio(SND_CLEAR),
  };
  for (const a of Object.values(sounds)){ a.preload="auto"; a.volume=0.9; }

  let audioUnlocked=false;
  async function unlockAudioOnce(){
    if(audioUnlocked) return;
    audioUnlocked=true;
    try{
      const a=sounds.spawn;
      const v=a.volume; a.volume=0;
      a.currentTime=0;
      await a.play();
      a.pause(); a.currentTime=0;
      a.volume=v;
    }catch(e){ console.warn("audio unlock failed:", e); }
  }
  function playSound(key){
    const a=sounds[key]; if(!a) return;
    try{ a.pause(); a.currentTime=0; a.play().catch(()=>{}); }catch{}
  }

  // ==========================
  // 10円画像
  // ==========================
  const coinSprite = { img:null, ready:false,
    async load(){
      if(this.ready) return;
      this.img = new Image();
      await new Promise((res,rej)=>{
        this.img.onload=res; this.img.onerror=rej;
        this.img.src = COIN_IMG_URL + "?t=" + Date.now();
      });
      this.ready=true;
    }
  };

  // ==========================
  // Matter
  // ==========================
  const elWorld = $("world");
  const Matter = window.Matter;
  const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

  let engine=null, render=null, runner=null;
  let renCanvas=null, renCtx=null, renData=null;
  let mapW=0, mapH=0;

  let blackMask=null;
  let coin=null;
  let spawnPoint={x:100,y:100};

  let springs=[], holes=[], goals=[];
  let touchingGround=false;
  let lastGroundNormal=null;

  // 役割
  let role="spectator";
  let isPlaying=false;

  // 操作監視
  let lastMyActionAt=Date.now();
  const AFK_LIMIT_MS=60_000;

  // 観戦描画用
  let remoteSnapshot=null;

  // レバー
  let lever={enabled:false,activeSpring:null,dragging:false,pointerId:null,startX:0,currentX:0,pullRatio:0};

  // 強化値（動作優先で固定）
  const IMPULSE_MULT=1.5;
  const UPWARD_BIAS_FIXED=0;
  const SLOPE_ACCEL_MULT=2.0;
  const SLOPE_EXTRA_MULT=3.8;     // ←さらに上げた
  const STUCK_BOOST_MULT=5.0;     // ←さらに上げた
  const STUCK_SPEED_TH=0.30;
  const MIN_SIN_TO_APPLY=0.012;

  // ==========================
  // 画像ロード（mapバグ対策の要）
  // ==========================
  async function loadImage(url){
    const img=new Image();
    // キャッシュ回避を必ず付ける
    const u = url + (url.includes("?") ? "&" : "?") + "t=" + Date.now();
    await new Promise((res,rej)=>{
      img.onload=res;
      img.onerror=()=>rej(new Error("Failed to load: "+url));
      img.src=u;
    });
    return img;
  }

  async function chooseBackgroundURL(){
    // map.png を「読めるかどうか」を必ず判定
    try{
      await loadImage(MAP_URL);
      return MAP_URL;
    }catch(e){
      console.warn(e);
      return REN_URL;
    }
  }

  async function loadRen(){
    const img = await loadImage(REN_URL);
    mapW = img.naturalWidth || img.width;
    mapH = img.naturalHeight || img.height;

    renCanvas=document.createElement("canvas");
    renCanvas.width=mapW; renCanvas.height=mapH;
    renCtx=renCanvas.getContext("2d",{willReadFrequently:true});
    renCtx.drawImage(img,0,0);
    renData=renCtx.getImageData(0,0,mapW,mapH);
  }

  function classifyPixel(r,g,b,a){
    if (a < 10) return "empty";
    if (r < 40 && g < 40 && b < 40) return "black";
    if (r > 180 && g < 80 && b < 80) return "red";
    if (g > 160 && r < 120 && b < 120) return "green";
    if (r > 180 && g > 180 && b < 120) return "yellow";
    if (b > 180 && r < 100 && g < 140) return "blue";
    return "empty";
  }

  function buildMasks(){
    const w=mapW,h=mapH;
    const data=renData.data;
    const black=new Uint8Array(w*h);
    const red=new Uint8Array(w*h);
    const green=new Uint8Array(w*h);
    const yellow=new Uint8Array(w*h);
    const blue=new Uint8Array(w*h);

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        const c=classifyPixel(r,g,b,a);
        const p=y*w+x;
        if(c==="black") black[p]=1;
        else if(c==="red") red[p]=1;
        else if(c==="green") green[p]=1;
        else if(c==="yellow") yellow[p]=1;
        else if(c==="blue") blue[p]=1;
      }
    }
    return {black,red,green,yellow,blue};
  }

  function extractComponents(mask,w,h){
    const visited=new Uint8Array(w*h);
    const comps=[];
    const qx=new Int32Array(w*h);
    const qy=new Int32Array(w*h);
    const idx=(x,y)=>y*w+x;
    const push=(x,y,t)=>{qx[t]=x; qy[t]=y; return t+1;};

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i=idx(x,y);
        if(!mask[i] || visited[i]) continue;

        let head=0,tail=0;
        tail=push(x,y,tail); visited[i]=1;

        let sumX=0,sumY=0,area=0;
        let minX=x,minY=y,maxX=x,maxY=y;

        while(head<tail){
          const cx=qx[head],cy=qy[head]; head++;
          area++; sumX+=cx; sumY+=cy;
          if(cx<minX)minX=cx; if(cy<minY)minY=cy;
          if(cx>maxX)maxX=cx; if(cy>maxY)maxY=cy;

          const n1=(cx>0)?idx(cx-1,cy):-1;
          const n2=(cx<w-1)?idx(cx+1,cy):-1;
          const n3=(cy>0)?idx(cx,cy-1):-1;
          const n4=(cy<h-1)?idx(cx,cy+1):-1;

          if(n1>=0 && mask[n1] && !visited[n1]){visited[n1]=1; tail=push(cx-1,cy,tail);}
          if(n2>=0 && mask[n2] && !visited[n2]){visited[n2]=1; tail=push(cx+1,cy,tail);}
          if(n3>=0 && mask[n3] && !visited[n3]){visited[n3]=1; tail=push(cx,cy-1,tail);}
          if(n4>=0 && mask[n4] && !visited[n4]){visited[n4]=1; tail=push(cx,cy+1,tail);}
        }
        comps.push({area, centroid:{x:sumX/area, y:sumY/area}, aabb:{minX,minY,maxX,maxY}});
      }
    }
    comps.sort((a,b)=>b.area-a.area);
    return comps;
  }

  function smoothBinaryMask(mask,w,h,iters=2,threshold=0.58){
    let src=mask;
    let dst=new Uint8Array(w*h);
    const idx=(x,y)=>y*w+x;
    for(let iter=0; iter<iters; iter++){
      dst.fill(0);
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let c=0;
          c+=src[idx(x-1,y-1)]; c+=src[idx(x,y-1)]; c+=src[idx(x+1,y-1)];
          c+=src[idx(x-1,y)];   c+=src[idx(x,y)];   c+=src[idx(x+1,y)];
          c+=src[idx(x-1,y+1)]; c+=src[idx(x,y+1)]; c+=src[idx(x+1,y+1)];
          dst[idx(x,y)] = (c/9>=threshold)?1:0;
        }
      }
      const tmp=src; src=dst; dst=tmp;
    }
    return src;
  }

  function extractBoundaryPoints(mask,w,h){
    const pts=[];
    const idx=(x,y)=>y*w+x;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i=idx(x,y);
        if(!mask[i]) continue;
        if(!mask[idx(x-1,y)]||!mask[idx(x+1,y)]||!mask[idx(x,y-1)]||!mask[idx(x,y+1)]) pts.push({x,y});
      }
    }
    return pts;
  }

  function pointsToSegmentsApproxSmooth(points,sampleStep=6,grid=2){
    const segs=[];
    const snap=(v)=>Math.round(v/grid)*grid;
    const pts=[];
    for(let i=0;i<points.length;i+=sampleStep){
      const p=points[i];
      pts.push({x:snap(p.x),y:snap(p.y)});
    }
    const maxD2=(sampleStep*sampleStep*20);
    const minD2=4;

    for(let i=0;i<pts.length;i++){
      const p=pts[i];
      let bestJ=-1, bestD2=Infinity;
      for(let j=i+1;j<Math.min(pts.length,i+220);j++){
        const q=pts[j];
        const dx=q.x-p.x, dy=q.y-p.y;
        const d2=dx*dx+dy*dy;
        if(d2<minD2) continue;
        if(d2<bestD2 && d2<maxD2){bestD2=d2; bestJ=j;}
      }
      if(bestJ>=0){
        const q=pts[bestJ];
        segs.push({x1:p.x,y1:p.y,x2:q.x,y2:q.y});
      }
    }
    return segs;
  }

  function segmentToBody(seg){
    const x1=seg.x1,y1=seg.y1,x2=seg.x2,y2=seg.y2;
    const mx=(x1+x2)/2, my=(y1+y2)/2;
    const dx=x2-x1, dy=y2-y1;
    const len=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx);
    return Bodies.rectangle(mx,my,len,6,{isStatic:true, friction:0.55, restitution:0, angle:ang, render:{visible:false}});
  }

  function destroyGame(){
    if(render){ Render.stop(render); render.canvas.remove(); render.textures={}; render=null; }
    if(runner){ Runner.stop(runner); runner=null; }
    if(engine){ World.clear(engine.world,false); Engine.clear(engine); engine=null; }
    coin=null; springs=[]; holes=[]; goals=[];
    touchingGround=false; lastGroundNormal=null;
    remoteSnapshot=null;
  }

  function createEngine(){
    engine=Engine.create();
    engine.gravity.y = 1;
  }
  function createRenderer(bgUrl){
    render=Render.create({
      element: elWorld,
      engine,
      options:{width:mapW,height:mapH,wireframes:false,background:"#000",hasBounds:false,pixelRatio:window.devicePixelRatio||1}
    });

    // ★ mapバグ対策：styleに確実に設定（options.backgroundは使わない）
    render.canvas.style.backgroundImage = `url(${bgUrl})`;
    render.canvas.style.backgroundSize = "100% 100%";
    render.canvas.style.backgroundRepeat = "no-repeat";
    render.canvas.style.backgroundPosition = "0 0";
  }

  function resizeCanvasToFit(){
    if(!render) return;
    const rect = elWorld.getBoundingClientRect();
    const scale = Math.min(rect.width / mapW, rect.height / mapH);
    render.canvas.style.width = (mapW*scale)+"px";
    render.canvas.style.height = (mapH*scale)+"px";
  }

  function addTerrainFromBlack(mask){
    const smooth = smoothBinaryMask(mask, mapW, mapH, 2, 0.58);
    blackMask = smooth;
    const boundary = extractBoundaryPoints(smooth,mapW,mapH);
    const segs = pointsToSegmentsApproxSmooth(boundary, 6, 2);
    const bodies=[];
    for(const seg of segs){
      const b=segmentToBody(seg);
      b.label="terrain";
      bodies.push(b);
    }
    World.add(engine.world,bodies);
  }

  function addSpringsFromYellow(yellowComps){
    springs=[];
    const centerX=mapW/2;
    const picked=yellowComps.slice(0,6);
    for(const c of picked){
      const dir = (c.centroid.x < centerX) ? +1 : -1;
      const pad=8;
      const aabb={minX:c.aabb.minX-pad, minY:c.aabb.minY-pad, maxX:c.aabb.maxX+pad, maxY:c.aabb.maxY+pad};
      const sensor=Bodies.rectangle((aabb.minX+aabb.maxX)/2,(aabb.minY+aabb.maxY)/2,Math.max(10,aabb.maxX-aabb.minX),Math.max(10,aabb.maxY-aabb.minY),{isStatic:true,isSensor:true,render:{visible:false}});
      sensor.label="springSensor";
      springs.push({sensor, center:{x:c.centroid.x,y:c.centroid.y}, dir, cooldownUntil:0, aabb});
    }
    World.add(engine.world, springs.map(s=>s.sensor));
  }

  function addSensors(redComps, blueComps){
    holes=[]; goals=[];
    for(const c of redComps){
      let r=Math.sqrt(c.area/Math.PI); r=Math.max(12,Math.min(90,r));
      const b=Bodies.circle(c.centroid.x,c.centroid.y,r,{isStatic:true,isSensor:true,render:{visible:false}});
      b.label="hole"; holes.push(b);
    }
    for(const c of blueComps){
      let r=Math.sqrt(c.area/Math.PI); r=Math.max(14,Math.min(110,r));
      const b=Bodies.circle(c.centroid.x,c.centroid.y,r,{isStatic:true,isSensor:true,render:{visible:false}});
      b.label="goal"; goals.push(b);
    }
    World.add(engine.world, holes.concat(goals));
  }

  function addCoinNew(){
    if(coin){ World.remove(engine.world, coin); coin=null; }
    coin=Bodies.circle(spawnPoint.x,spawnPoint.y,32,{
      restitution:0, friction:0.012, frictionStatic:0.15, frictionAir:0.006, density:0.005,
      render:{visible:false}
    });
    World.add(engine.world, coin);
    playSound("spawn");
  }

  function respawnCoin(){
    if(!coin) return;
    Body.setPosition(coin,{x:spawnPoint.x,y:spawnPoint.y});
    Body.setVelocity(coin,{x:0,y:0});
    Body.setAngularVelocity(coin,0);
    playSound("spawn");
  }

  // ===== 坂補助（より強化）=====
  function isBlackAt(x,y){
    if(!blackMask) return false;
    x=Math.max(0,Math.min(mapW-1,x|0));
    y=Math.max(0,Math.min(mapH-1,y|0));
    return blackMask[y*mapW+x]===1;
  }
  function findGroundY(x,startY,maxDown=160){
    const sx=x|0;
    let y=Math.max(0,Math.min(mapH-1,startY|0));
    for(let i=0;i<maxDown;i++){
      const yy=y+i;
      if(yy>=mapH) break;
      if(isBlackAt(sx,yy) && !isBlackAt(sx,yy-1)) return yy;
    }
    return null;
  }
  function estimateSlopeAtCoin(){
    const probe=34;
    const px=coin.position.x, py=coin.position.y;
    const startY = py + 32*0.6;
    const xL=Math.max(0,Math.min(mapW-1,(px-probe)|0));
    const xR=Math.max(0,Math.min(mapW-1,(px+probe)|0));
    const yL=findGroundY(xL,startY);
    const yR=findGroundY(xR,startY);
    if(yL==null||yR==null) return null;
    const dx=xR-xL; if(dx<=0) return null;
    return { slope:(yR-yL)/dx };
  }
  function applySlopeAssist(){
    if(!touchingGround) return;
    const est=estimateSlopeAtCoin(); if(!est) return;
    const tan=est.slope;
    const sin = tan / Math.sqrt(1+tan*tan);
    if(Math.abs(sin) < MIN_SIN_TO_APPLY) return;

    const g=engine.gravity.y;
    let k = 2.5 * SLOPE_ACCEL_MULT * SLOPE_EXTRA_MULT;

    const speed=Math.hypot(coin.velocity.x, coin.velocity.y);
    if(speed < STUCK_SPEED_TH) k *= STUCK_BOOST_MULT;

    const ax = g * sin * k;
    const dt=0.016;
    let vx = coin.velocity.x + ax*dt;

    const downhillDir=(sin>0)?+1:-1;
    const minRoll=(speed<STUCK_SPEED_TH)?0.30:0.14;
    if(Math.sign(vx)===downhillDir && Math.abs(vx)<minRoll) vx=downhillDir*minRoll;

    Body.setVelocity(coin,{x:vx,y:coin.velocity.y});
  }

  // ===== 表示（map+coin+黄色枠）=====
  function drawYellowFrames(){
    const ctx=render.context;
    for(const s of springs){
      const active = (s===lever.activeSpring);
      ctx.save();
      ctx.strokeStyle = active ? "rgba(255,220,80,0.95)" : "rgba(255,255,0,0.55)";
      ctx.lineWidth = active ? 4 : 3;
      const a=s.aabb;
      ctx.strokeRect(a.minX,a.minY,a.maxX-a.minX,a.maxY-a.minY);
      ctx.font="bold 16px sans-serif";
      ctx.textAlign="center";
      ctx.fillStyle = active ? "rgba(255,220,80,0.95)" : "rgba(255,255,0,0.7)";
      ctx.fillText(s.dir>0?"→":"←", s.center.x, s.center.y-22);
      ctx.restore();
    }
  }
  function drawCoinSprite(ctx,x,y,angle,r){
    if(!coinSprite.ready) return;
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(angle||0);
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.clip();
    ctx.drawImage(coinSprite.img, -r, -r, r*2, r*2);
    ctx.restore();
  }

  // ===== クリア演出 =====
  let clearTimer=null;
  function showClearOverlay10s(){
    clearOverlay.style.display="flex";
    if(clearTimer) clearTimeout(clearTimer);
    clearTimer=setTimeout(()=>{clearOverlay.style.display="none";}, 10_000);
  }

  // ==========================
  // Firebase：イベント/同期/ロック
  // ==========================
  async function sendEvent(payload){
    await set(rEvent, payload).catch(()=>{});
  }

  async function tryAcquireLock(){
    const res = await runTransaction(rLock, (cur)=>{
      if(cur==null){
        return {playerId:myId, playerName:myName, startedAt:Date.now(), lastActionAt:Date.now()};
      }
      if(cur?.lastActionAt && (Date.now()-cur.lastActionAt>AFK_LIMIT_MS)){
        return {playerId:myId, playerName:myName, startedAt:Date.now(), lastActionAt:Date.now()};
      }
      return; // abort
    }, {applyLocally:false});
    return res.committed;
  }

  async function releaseLock(){
    await runTransaction(rLock, (cur)=>{
      if(cur?.playerId===myId) return null;
      return;
    }, {applyLocally:false}).catch(()=>{});
  }

  async function updateLockHeartbeat(){
    if(!(role==="player" && isPlaying)) return;
    await update(rLock, {lastActionAt:Date.now()}).catch(()=>{});
  }

  onDisconnect(rLock).remove().catch(()=>{});

  let snapInterval=null;
  function startSnapshotWriter(){
    stopSnapshotWriter();
    snapInterval=setInterval(async ()=>{
      if(!(role==="player" && isPlaying) || !coin) return;
      await set(rSnap,{
        playerId:myId, playerName:myName,
        x:coin.position.x,y:coin.position.y,vx:coin.velocity.x,vy:coin.velocity.y,angle:coin.angle,
        t:Date.now()
      }).catch(()=>{});
      await updateLockHeartbeat();
    }, 120);
  }
  function stopSnapshotWriter(){
    if(snapInterval){clearInterval(snapInterval); snapInterval=null;}
  }

  // 待機（10分更新）
  let waitHeartbeat=null;
  function startWaitHeartbeat(){
    stopWaitHeartbeat();
    waitHeartbeat=setInterval(async ()=>{
      if(role!=="spectator") return;
      await update(rWait,{[myId]:{name:myName, at:serverTimestamp()}}).catch(()=>{});
      waitLine.textContent = "待機リスト更新（10分）";
    }, 10*60*1000);
  }
  function stopWaitHeartbeat(){
    if(waitHeartbeat){clearInterval(waitHeartbeat); waitHeartbeat=null;}
  }

  // ==========================
  // Matterイベント（判定/音）
  // ==========================
  let lastHitAt=0;
  const HIT_COOLDOWN_MS=120;
  const HIT_SPEED_TH=7.5;

  function handleHitSound(ev){
    if(!coin) return;
    const now=performance.now();
    if(now-lastHitAt < HIT_COOLDOWN_MS) return;

    for(const pair of ev.pairs){
      const a=pair.bodyA,b=pair.bodyB;
      if(!(a===coin || b===coin)) continue;
      const other=(a===coin)?b:a;
      if(other.label!=="terrain") continue;
      const rel=Math.hypot(coin.velocity.x-(other.velocity?.x||0), coin.velocity.y-(other.velocity?.y||0));
      if(rel>=HIT_SPEED_TH){
        lastHitAt=now;
        playSound("hit");
        sendEvent({type:"hit", by:myName, at:serverTimestamp()});
        break;
      }
    }
  }

  function markMyAction(){ lastMyActionAt=Date.now(); }

  async function endPlay(reason="終了"){
    if(!(role==="player" && isPlaying)) return;
    isPlaying=false;
    role="spectator";
    stopSnapshotWriter();
    await releaseLock();

    btnEnd.disabled=true;
    btnResetCoin.disabled=true;
    btnRespawn.disabled=true;
    btnPlay.disabled=false;

    btnWait.disabled=false;
    startWaitHeartbeat();

    await sendEvent({type:"end", by:myName, reason, at:serverTimestamp()}).catch(()=>{});
  }

  function installEvents(){
    Events.on(engine,"collisionStart",(ev)=>{
      if(role==="player" && isPlaying) handleHitSound(ev);
    });

    Events.on(engine,"collisionActive",(ev)=>{
      touchingGround=false;
      lastGroundNormal=null;
      if(!coin) return;

      for(const pair of ev.pairs){
        const a=pair.bodyA,b=pair.bodyB;

        // red fail
        if((a===coin && b.label==="hole") || (b===coin && a.label==="hole")){
          if(role==="player" && isPlaying){
            playSound("fail");
            sendEvent({type:"fail", by:myName, at:serverTimestamp()});
            respawnCoin();
            markMyAction();
          }
          continue;
        }

        // blue clear
        if((a===coin && b.label==="goal") || (b===coin && a.label==="goal")){
          if(role==="player" && isPlaying){
            playSound("clear");
            sendEvent({type:"clear", by:myName, at:serverTimestamp()});
            showClearOverlay10s();
            respawnCoin();
            markMyAction();
          }
          continue;
        }

        const isTerrain = (a===coin && b.label==="terrain") || (b===coin && a.label==="terrain");
        if(isTerrain){
          touchingGround=true;
          lastGroundNormal=pair.collision.normal;
        }
      }
    });

    Events.on(engine,"afterUpdate",()=>{
      if(!coin) return;

      // active spring（表示用）
      const s = springs.length ? (()=> {
        const nearDist=180;
        let best=null, bestD2=Infinity;
        for(const sp of springs){
          const dx=coin.position.x-sp.center.x;
          const dy=coin.position.y-sp.center.y;
          const d2=dx*dx+dy*dy;
          const a=sp.aabb;
          const inside=(coin.position.x>=a.minX && coin.position.x<=a.maxX && coin.position.y>=a.minY && coin.position.y<=a.maxY);
          if(!(inside || d2<=nearDist*nearDist)) continue;
          if(d2<bestD2){bestD2=d2; best=sp;}
        }
        return best;
      })() : null;

      lever.activeSpring=s;
      lever.enabled=!!s && touchingGround;

      setLeverUI(lever.enabled && role==="player" && isPlaying, lever.pullRatio, s);

      if(role==="player" && isPlaying){
        applySlopeAssist();
        if(Date.now()-lastMyActionAt > AFK_LIMIT_MS){
          endPlay("無操作1分のため終了");
        }
      }

      // 平坦停止は最小限
      if(touchingGround && lastGroundNormal){
        const slopeMeasure=Math.abs(lastGroundNormal.x);
        if(Math.abs(coin.velocity.x)<0.03 && Math.abs(coin.angularVelocity)<0.012 && slopeMeasure<0.05){
          Body.setVelocity(coin,{x:0,y:coin.velocity.y});
          Body.setAngularVelocity(coin,0);
        }
      }

      if(isAdmin){
        statusEl.textContent =
`bg=${render?.canvas?.style?.backgroundImage || "-"}
role=${role} playing=${isPlaying}
coin=(${coin.position.x.toFixed(1)},${coin.position.y.toFixed(1)}) v=(${coin.velocity.x.toFixed(2)},${coin.velocity.y.toFixed(2)})
springs=${springs.length} holes=${holes.length} goals=${goals.length}`;
      } else {
        statusEl.textContent = "";
      }
    });

    Events.on(render,"afterRender",()=>{
      const ctx=render.context;

      // 観戦は remoteSnapshot を描画
      if(role==="spectator" && remoteSnapshot){
        drawCoinSprite(ctx, remoteSnapshot.x, remoteSnapshot.y, remoteSnapshot.angle, 32);
      } else {
        drawCoinSprite(ctx, coin.position.x, coin.position.y, coin.angle, 32);
      }
      drawYellowFrames();
    });
  }

  function setLeverUI(enabled, ratio, spring){
    const pct=Math.round(ratio*100);
    pullFill.style.width=pct+"%";
    pullKnob.style.left=pct+"%";
    powChip.textContent=pct+"%";

    if(!enabled){
      leverBadge.textContent="OFF";
      leverBadge.classList.add("off");
      dirChip.textContent="dir:-";
      pullArea.style.opacity="0.45";
      return;
    }
    leverBadge.classList.remove("off");
    leverBadge.textContent=lever.dragging?"CHARGING":"READY";
    pullArea.style.opacity="1";
    dirChip.textContent = spring ? (spring.dir>0 ? "dir:→(右)" : "dir:←(左)") : "dir:-";
  }

  function launchFromSpring(s, pullRatio){
    const now = performance.now()/1000;
    if(now < s.cooldownUntil) return;
    if(!touchingGround) return;

    const maxImpulse = 18;
    const cooldown = 0.30;
    const impulse = (maxImpulse * IMPULSE_MULT) * Math.max(0,Math.min(1,pullRatio));

    Body.setVelocity(coin, {x:s.dir*impulse, y:0});
    Body.setAngularVelocity(coin,0);
    s.cooldownUntil = now + cooldown;

    playSound("shot");
    sendEvent({type:"shot", by:myName, at:serverTimestamp()});
    markMyAction();
  }

  // レバー入力
  pullArea.addEventListener("pointerdown", async (e)=>{
    await unlockAudioOnce();
    if(!(role==="player" && isPlaying)) return;
    if(!lever.enabled || !touchingGround) return;

    lever.dragging=true;
    lever.pointerId=e.pointerId;
    lever.startX=e.clientX;
    lever.currentX=e.clientX;
    pullArea.setPointerCapture(e.pointerId);
    markMyAction();
  });

  pullArea.addEventListener("pointermove",(e)=>{
    if(!lever.dragging) return;
    if(lever.pointerId!==e.pointerId) return;
    lever.currentX=e.clientX;

    const s=lever.activeSpring;
    if(!s) return;

    const maxPull=150;
    const dx=lever.currentX-lever.startX;
    const pullSigned = -s.dir*dx;
    const pullPx=Math.max(0,Math.min(maxPull,pullSigned));
    lever.pullRatio=Math.max(0,Math.min(1,pullPx/maxPull));
    setLeverUI(true, lever.pullRatio, s);
    markMyAction();
  });

  function releaseLever(e){
    if(!lever.dragging) return;
    if(lever.pointerId!==e.pointerId) return;
    lever.dragging=false;

    const s=lever.activeSpring;
    const r=lever.pullRatio;
    if(s && r>0 && role==="player" && isPlaying){
      launchFromSpring(s,r);
    }
    lever.pullRatio=0;
    setLeverUI(role==="player" && isPlaying && lever.enabled, 0, lever.activeSpring);
    markMyAction();
  }
  pullArea.addEventListener("pointerup", releaseLever);
  pullArea.addEventListener("pointercancel", releaseLever);

  // ==========================
  // Firebase購読
  // ==========================
  function subscribe(){
    onValue(rLock,(snap)=>{
      const v=snap.val();
      if(!v){
        currentPlayerLine.textContent="誰もプレイしていません";
        if(!(role==="player" && isPlaying)){
          btnPlay.disabled=false;
          btnWait.disabled=false;
        }
        return;
      }
      currentPlayerLine.textContent=`${v.playerName} がプレイ中`;
      if(!(role==="player" && isPlaying)){
        btnPlay.disabled=true;
        btnWait.disabled=false;
      }
    });

    onValue(rWait,(snap)=>{
      const v=snap.val()||{};
      const names=Object.values(v).map(x=>x?.name).filter(Boolean);
      waitLine.textContent = names.length ? `待機: ${names.join(" / ")}` : "";
    });

    onValue(rEvent,(snap)=>{
      const e=snap.val();
      if(!e?.type) return;
      if(role==="player" && isPlaying) return; // プレイヤーはローカルで鳴らす
      if(e.type==="shot") playSound("shot");
      else if(e.type==="hit") playSound("hit");
      else if(e.type==="fail") playSound("fail");
      else if(e.type==="spawn") playSound("spawn");
      else if(e.type==="clear") playSound("clear");
    });

    onValue(rSnap,(snap)=>{
      const v=snap.val();
      if(role==="spectator") remoteSnapshot = v || null;
    });
  }

  // ==========================
  // boot
  // ==========================
  async function bootCoinGame(){
    destroyGame();
    await coinSprite.load();
    await loadRen();

    const bg = await chooseBackgroundURL();
    if(isAdmin) bgDebug.textContent = `背景: ${bg}（mapが読めない場合 ren にフォールバック）`;

    const masks=buildMasks();
    const greenComps=extractComponents(masks.green,mapW,mapH);
    spawnPoint = greenComps.length ? greenComps[0].centroid : {x:100,y:100};

    createEngine();
    createRenderer(bg);
    runner=Runner.create();
    Render.run(render);
    Runner.run(runner, engine);
    resizeCanvasToFit();
    window.addEventListener("resize", resizeCanvasToFit, {passive:true});

    addTerrainFromBlack(masks.black);
    addSensors(extractComponents(masks.red,mapW,mapH), extractComponents(masks.blue,mapW,mapH));
    addSpringsFromYellow(extractComponents(masks.yellow,mapW,mapH));
    addCoinNew();
    installEvents();

    // 初期は観戦
    role="spectator";
    isPlaying=false;
    btnEnd.disabled=true;
    btnResetCoin.disabled=true;
    btnRespawn.disabled=true;
    btnPlay.disabled=false;
    btnWait.disabled=false;
    startWaitHeartbeat();
  }

  // センサー追加
  function addSensors(redComps, blueComps){
    holes=[]; goals=[];
    for(const c of redComps){
      let r=Math.sqrt(c.area/Math.PI); r=Math.max(12,Math.min(90,r));
      const b=Bodies.circle(c.centroid.x,c.centroid.y,r,{isStatic:true,isSensor:true,render:{visible:false}});
      b.label="hole"; holes.push(b);
    }
    for(const c of blueComps){
      let r=Math.sqrt(c.area/Math.PI); r=Math.max(14,Math.min(110,r));
      const b=Bodies.circle(c.centroid.x,c.centroid.y,r,{isStatic:true,isSensor:true,render:{visible:false}});
      b.label="goal"; goals.push(b);
    }
    World.add(engine.world, holes.concat(goals));
  }

  // ==========================
  // UIイベント
  // ==========================
  btnSelectJanken.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    selectMsg.textContent="じゃんけんは準備中です。";
  });
  btnSelectCoin.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    showScreen("name");
  });
  btnNameBack.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    showScreen("select");
  });
  btnNameOk.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    myName=(nameInput.value||"").trim() || "匿名";
    meLine.textContent=`${myName}（id:${myId.slice(0,8)}）`;
    showScreen("coin");
    await bootCoinGame();
  });

  adminEnter.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if(adminPass.value==="1122"){
      setAdminMode(true);
      adminMsg.textContent="運営モードON";
      adminPass.value="";
      bgDebug.textContent = render?.canvas?.style?.backgroundImage ? `背景: ${render.canvas.style.backgroundImage}` : "背景: -";
    }else{
      adminMsg.textContent="パスワードが違います";
    }
  });
  adminExit.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    setAdminMode(false);
    adminMsg.textContent="運営モードOFF";
  });

  btnReload?.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if(!isAdmin) return;
    await bootCoinGame();
  });

  btnPlay.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    const ok = await (async ()=>{
      const res = await runTransaction(rLock, (cur)=>{
        if(cur==null){
          return {playerId:myId, playerName:myName, startedAt:Date.now(), lastActionAt:Date.now()};
        }
        if(cur?.lastActionAt && (Date.now()-cur.lastActionAt>AFK_LIMIT_MS)){
          return {playerId:myId, playerName:myName, startedAt:Date.now(), lastActionAt:Date.now()};
        }
        return;
      }, {applyLocally:false});
      return res.committed;
    })();

    if(!ok){
      alert("他の人がプレイ中です。");
      return;
    }

    role="player";
    isPlaying=true;
    btnEnd.disabled=false;
    btnResetCoin.disabled=false;
    btnRespawn.disabled=false;
    btnPlay.disabled=true;

    await update(rWait,{[myId]:null}).catch(()=>{});
    stopWaitHeartbeat();

    onDisconnect(rLock).remove().catch(()=>{});
    lastMyActionAt=Date.now();

    // 観戦同期停止（自分が動かす）
    remoteSnapshot=null;

    // snapshot writer
    if(window.__snapInterval) clearInterval(window.__snapInterval);
    window.__snapInterval=setInterval(async ()=>{
      if(!(role==="player" && isPlaying) || !coin) return;
      await set(rSnap,{playerId:myId, playerName:myName, x:coin.position.x, y:coin.position.y, vx:coin.velocity.x, vy:coin.velocity.y, angle:coin.angle, t:Date.now()}).catch(()=>{});
      await update(rLock,{lastActionAt:Date.now()}).catch(()=>{});
    },120);

    await sendEvent({type:"start", by:myName, at:serverTimestamp()}).catch(()=>{});
  });

  btnEnd.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    await (async ()=>{
      isPlaying=false;
      role="spectator";
      btnEnd.disabled=true;
      btnResetCoin.disabled=true;
      btnRespawn.disabled=true;
      btnPlay.disabled=false;

      if(window.__snapInterval){clearInterval(window.__snapInterval); window.__snapInterval=null;}
      await runTransaction(rLock, (cur)=> (cur?.playerId===myId ? null : cur), {applyLocally:false}).catch(()=>{});
      startWaitHeartbeat();
      await sendEvent({type:"end", by:myName, at:serverTimestamp()}).catch(()=>{});
    })();
  });

  btnResetCoin.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if(!(role==="player" && isPlaying)) return;
    respawnCoin();
    await sendEvent({type:"spawn", by:myName, at:serverTimestamp()});
    markMyAction();
  });

  btnRespawn.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if(!(role==="player" && isPlaying)) return;
    addCoinNew();
    await sendEvent({type:"spawn", by:myName, at:serverTimestamp()});
    markMyAction();
  });

  btnWait.addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if(role==="player" && isPlaying) return;
    await update(rWait,{[myId]:{name:myName, at:serverTimestamp()}}).catch(()=>{});
    waitLine.textContent="待機中…";
    startWaitHeartbeat();
  });

  // ==========================
  // subscribe once
  // ==========================
  subscribe();

  // start
  showScreen("select");
  selectMsg.textContent="10円ゲームを選んでください。";
</script>
</body>
</html>
