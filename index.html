<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>10円ゲーム (Matter.js / ren.png から自動生成)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --ui-w: 320px;
      --bg: #111;
      --panel: #0b0b0b;
      --border: #333;
      --text: #eee;
      --muted: #bbb;
      --accent: #ffd24a;
    }
    html, body {
      margin:0; padding:0;
      height:100%;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow:hidden;
    }

    /* 画面を「UI(左) + ゲーム(右)」で常に100%表示 */
    #wrap{
      display:grid;
      grid-template-columns: var(--ui-w) 1fr;
      height:100vh;
      width:100vw;
    }

    #ui{
      padding: 12px;
      box-sizing:border-box;
      border-right: 1px solid var(--border);
      background:var(--panel);
      overflow:auto;
    }
    #ui h1 { font-size: 14px; margin: 0 0 10px; }
    #ui .row { margin: 10px 0; }
    #ui .label { color:var(--muted); font-size: 11px; margin-bottom:6px; }
    #ui button{
      background:#333; color:#eee; border:1px solid #555; border-radius:6px;
      padding: 7px 10px; cursor:pointer; font-size: 12px;
    }
    #ui button:hover { background:#444; }
    #ui input[type="number"]{
      width: 92px; background:#222; color:#eee; border:1px solid #555; border-radius:6px; padding:4px 8px;
    }
    #hint { color:#9bd; line-height: 1.5; font-size: 12px; }
    #status { white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 11px; color:#cfc; }

    /* 右側は「ゲームが必ず見える」レイアウト */
    #world{
      position:relative;
      overflow:hidden;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* Matter.js の canvas は JS 側で作られるので、ここで見た目を調整 */
    #world canvas{
      display:block;
      background:#000;
      /* 重要：画面に収��るように縮小（contain） */
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      image-rendering: auto;
    }

    /* レバーUI（黄色の横に出る） */
    .lever {
      position:absolute;
      width: 210px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      background: rgba(10,10,10,0.78);
      backdrop-filter: blur(2px);
      color: #fff;
      pointer-events: auto;
      user-select: none;
      box-sizing: border-box;
    }
    .lever .title{
      font-size: 12px;
      color: var(--accent);
      margin-bottom: 8px;
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .lever .sub{
      font-size: 11px;
      color: rgba(255,255,255,0.7);
      margin-top: 6px;
      line-height: 1.4;
    }

    /* 引っ張りエリア */
    .pullArea{
      width: 100%;
      height: 42px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.06);
      position: relative;
      overflow:hidden;
      cursor: grab;
    }
    .pullArea:active{ cursor: grabbing; }

    .pullFill{
      position:absolute;
      left:0; top:0; bottom:0;
      width:0%;
      background: linear-gradient(90deg, #22ff66, #ffee55, #ff8a22, #ff2a2a);
      opacity: 0.85;
    }
    .pullKnob{
      position:absolute;
      top: 50%;
      transform: translate(-50%,-50%);
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 2px 10px rgba(0,0,0,0.45);
      left: 0%;
    }

    .mini{
      font-size: 11px;
      color: rgba(255,255,255,0.78);
      margin-top: 8px;
      display:flex;
      justify-content:space-between;
    }
    .badge{
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .badge.max{
      color:#fff;
      background: rgba(255,0,0,0.18);
      border-color: rgba(255,0,0,0.35);
      font-weight: 700;
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <h1>10円ゲーム（自動生成）</h1>

    <div class="row" id="hint">
      ・入力: ren.png（黒=地形 / 赤=穴 / 緑=開始 / 黄=レバー(バネ)）<br>
      ・操作: コインが黄色範囲内のとき、黄色の横に出るレバーをドラッグして溜める → 離すと発射<br>
      ・向き: 左側の黄色→右へ / 右側の黄色→左へ
    </div>

    <div class="row">
      <div class="label">コイン半径(px)</div>
      <input id="coinR" type="number" value="32" min="4" max="128">
    </div>

    <div class="row">
      <div class="label">重力（Matter）</div>
      <input id="gravityY" type="number" value="1" step="0.1" min="0" max="5">
    </div>

    <div class="row">
      <div class="label">最大発射速度</div>
      <input id="maxImpulse" type="number" value="18" step="1" min="1" max="80">
    </div>

    <div class="row">
      <div class="label">上方向バイアス</div>
      <input id="verticalBias" type="number" value="0.22" step="0.01" min="0" max="1">
    </div>

    <div class="row">
      <div class="label">レバー：最大引き量(px)</div>
      <input id="maxPull" type="number" value="150" step="10" min="50" max="400">
    </div>

    <div class="row">
      <button id="reloadBtn">ren.png から再生成</button>
      <button id="respawnBtn">リスポーン</button>
    </div>

    <div class="row">
      <div class="label">状態</div>
      <div id="status">loading...</div>
    </div>

    <div class="row" style="color:#888">
      ※ index.html は線エディタのまま残しています。<br>
      game.html を開いてください。
    </div>
  </div>

  <div id="world"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>

<script>
(() => {
  const REN_URL = "ren.png";

  function classifyPixel(r,g,b,a){
    if (a < 10) return "empty";
    if (r < 40 && g < 40 && b < 40) return "black";
    if (r > 180 && g < 80 && b < 80) return "red";
    if (g > 160 && r < 120 && b < 120) return "green";
    if (r > 180 && g > 180 && b < 120) return "yellow";
    return "empty";
  }

  function extractComponents(mask, w, h){
    const visited = new Uint8Array(w*h);
    const comps = [];
    const qx = new Int32Array(w*h);
    const qy = new Int32Array(w*h);

    const idx = (x,y)=>y*w+x;
    const push = (x,y,tail)=>{ qx[tail]=x; qy[tail]=y; return tail+1; };

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = idx(x,y);
        if (!mask[i] || visited[i]) continue;

        let head=0, tail=0;
        tail = push(x,y,tail);
        visited[i]=1;

        let sumX=0, sumY=0, area=0;
        let minX=x, minY=y, maxX=x, maxY=y;

        while(head<tail){
          const cx=qx[head], cy=qy[head]; head++;
          area++;
          sumX += cx; sumY += cy;
          if (cx<minX) minX=cx; if (cy<minY) minY=cy;
          if (cx>maxX) maxX=cx; if (cy>maxY) maxY=cy;

          const n1 = (cx>0)   ? idx(cx-1,cy) : -1;
          const n2 = (cx<w-1) ? idx(cx+1,cy) : -1;
          const n3 = (cy>0)   ? idx(cx,cy-1) : -1;
          const n4 = (cy<h-1) ? idx(cx,cy+1) : -1;

          if (n1>=0 && mask[n1] && !visited[n1]){ visited[n1]=1; tail=push(cx-1,cy,tail); }
          if (n2>=0 && mask[n2] && !visited[n2]){ visited[n2]=1; tail=push(cx+1,cy,tail); }
          if (n3>=0 && mask[n3] && !visited[n3]){ visited[n3]=1; tail=push(cx,cy-1,tail); }
          if (n4>=0 && mask[n4] && !visited[n4]){ visited[n4]=1; tail=push(cx,cy+1,tail); }
        }

        comps.push({
          area,
          centroid: { x: sumX / area, y: sumY / area },
          aabb: { minX, minY, maxX, maxY }
        });
      }
    }

    comps.sort((a,b)=>b.area-a.area);
    return comps;
  }

  function extractBoundaryPoints(blackMask, w, h){
    const pts = [];
    const idx = (x,y)=>y*w+x;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i = idx(x,y);
        if (!blackMask[i]) continue;
        if (!blackMask[idx(x-1,y)] || !blackMask[idx(x+1,y)] || !blackMask[idx(x,y-1)] || !blackMask[idx(x,y+1)]) {
          pts.push({x,y});
        }
      }
    }
    return pts;
  }

  function pointsToSegmentsApprox(points, sampleStep=6){
    const segs = [];
    for(let i=0;i<points.length;i+=sampleStep){
      const p = points[i];
      if (!p) continue;

      let bestJ = -1;
      let bestD2 = Infinity;
      for(let j=i+1;j<Math.min(points.length, i+200);j++){
        const q = points[j];
        const dx=q.x-p.x, dy=q.y-p.y;
        const d2=dx*dx+dy*dy;
        if (d2>1 && d2<bestD2 && d2< (sampleStep*sampleStep*16)) {
          bestD2=d2; bestJ=j;
        }
      }
      if (bestJ>=0){
        const q = points[bestJ];
        segs.push({x1:p.x,y1:p.y,x2:q.x,y2:q.y});
      }
    }
    return segs;
  }

  function segmentToBody(Matter, seg, thickness=4, opt={}){
    const { Bodies } = Matter;
    const x1=seg.x1, y1=seg.y1, x2=seg.x2, y2=seg.y2;
    const mx=(x1+x2)/2, my=(y1+y2)/2;
    const dx=x2-x1, dy=y2-y1;
    const len=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx);
    return Bodies.rectangle(mx, my, len, thickness, {
      isStatic:true,
      friction: 0.9,
      restitution: 0,
      angle: ang,
      ...opt
    });
  }

  const elWorld = document.getElementById("world");
  const statusEl = document.getElementById("status");
  const reloadBtn = document.getElementById("reloadBtn");
  const respawnBtn = document.getElementById("respawnBtn");

  const coinRInput = document.getElementById("coinR");
  const gravityYInput = document.getElementById("gravityY");
  const maxImpulseInput = document.getElementById("maxImpulse");
  const verticalBiasInput = document.getElementById("verticalBias");
  const maxPullInput = document.getElementById("maxPull");

  const Matter = window.Matter;
  const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

  let engine, render, runner;
  let renImage, renCanvas, renCtx, renData;
  let mapW=0, mapH=0;

  let coin=null;
  let spawnPoint={x:100,y:100};

  let holes=[];
  let springs=[]; // { sensor, center, dir, cooldownUntil, aabb }

  let touchingGround = false;
  let lastGroundNormal = null;

  // レバーDOM
  let leverEl = null;
  let leverState = {
    visible: false,
    spring: null,
    dragging: false,
    power01: 0,
    pointerId: null,
    startX: 0,
    currentX: 0
  };

  function setStatus(lines){ statusEl.textContent = lines.join("\n"); }

  function destroyLever(){
    if (leverEl){
      leverEl.remove();
      leverEl = null;
    }
    leverState = {
      visible:false, spring:null, dragging:false, power01:0,
      pointerId:null, startX:0, currentX:0
    };
  }

  function destroyWorld(){
    destroyLever();
    if (render) {
      Render.stop(render);
      render.canvas.remove();
      render.textures = {};
      render = null;
    }
    if (runner) { Runner.stop(runner); runner=null; }
    if (engine) { World.clear(engine.world, false); Engine.clear(engine); engine=null; }
    holes=[]; springs=[];
    coin=null;
  }

  async function loadRenPng(){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = REN_URL + "?t=" + Date.now();
    });
  }

  function buildRenImageData(img){
    mapW = img.naturalWidth || img.width;
    mapH = img.naturalHeight || img.height;

    renCanvas = document.createElement("canvas");
    renCanvas.width = mapW;
    renCanvas.height = mapH;
    renCtx = renCanvas.getContext("2d", { willReadFrequently:true });
    renCtx.drawImage(img, 0, 0);
    renData = renCtx.getImageData(0,0,mapW,mapH);
  }

  function buildMasks(){
    const w=mapW, h=mapH;
    const data=renData.data;
    const black = new Uint8Array(w*h);
    const red   = new Uint8Array(w*h);
    const green = new Uint8Array(w*h);
    const yellow= new Uint8Array(w*h);

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = (y*w+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        const c = classifyPixel(r,g,b,a);
        const p = y*w+x;
        if (c==="black") black[p]=1;
        else if (c==="red") red[p]=1;
        else if (c==="green") green[p]=1;
        else if (c==="yellow") yellow[p]=1;
      }
    }
    return {black, red, green, yellow};
  }

  function createEngineAndRenderer(){
    engine = Engine.create();
    engine.gravity.y = parseFloat(gravityYInput.value) || 1;

    render = Render.create({
      element: elWorld,
      engine,
      options: {
        width: mapW,
        height: mapH,
        wireframes: false,
        background: "#000",
        hasBounds: false,
        pixelRatio: window.devicePixelRatio || 1
      }
    });

    runner = Runner.create();
    Render.run(render);
    Runner.run(runner, engine);

    // 背景として ren.png（見やすさ優先で contain っぽく見せたいが、canvas内背景なのでまずは100%）
    render.options.background = `url(${REN_URL})`;
    render.canvas.style.backgroundSize = "100% 100%";
    render.canvas.style.backgroundRepeat = "no-repeat";

    // 画面に必ず収める（canvasをCSSで縮小）
    requestAnimationFrame(resizeCanvasToFit);
    window.addEventListener("resize", resizeCanvasToFit);
  }

  function resizeCanvasToFit(){
    if (!render) return;
    const canvas = render.canvas;
    const worldRect = elWorld.getBoundingClientRect();

    // 元の論理サイズ
    const w = mapW, h = mapH;

    // contain: min(横比, 縦比)
    const scale = Math.min(worldRect.width / w, worldRect.height / h);

    canvas.style.width  = (w * scale) + "px";
    canvas.style.height = (h * scale) + "px";
  }

  function addCoin(){
    const r = parseFloat(coinRInput.value) || 32;

    coin = Bodies.circle(spawnPoint.x, spawnPoint.y, r, {
      restitution: 0,
      friction: 0.05,
      frictionStatic: 0.85,
      frictionAir: 0.01,
      density: 0.005,
      render: {
        fillStyle: "#b87333",
        strokeStyle: "#5b2a12",
        lineWidth: 2
      }
    });

    World.add(engine.world, coin);
  }

  function respawn(){
    if (!coin) return;
    Body.setPosition(coin, {x:spawnPoint.x, y:spawnPoint.y});
    Body.setVelocity(coin, {x:0, y:0});
    Body.setAngularVelocity(coin, 0);
  }

  function addHolesFromComponents(redComps){
    holes = [];
    for (const c of redComps){
      let r = Math.sqrt(c.area / Math.PI);
      r = Math.max(12, Math.min(90, r));

      const hole = Bodies.circle(c.centroid.x, c.centroid.y, r, {
        isStatic: true,
        isSensor: true,
        render: { fillStyle: "rgba(255,0,0,0.25)", strokeStyle: "rgba(255,0,0,0.7)", lineWidth: 1 }
      });
      hole.label = "hole";
      holes.push(hole);
    }
    World.add(engine.world, holes);
  }

  function addSpringsFromComponents(yellowComps){
    springs = [];
    const centerX = mapW / 2;

    const picked = yellowComps.slice(0, 6);

    for (const c of picked){
      // 要望：右側にある黄色は左、左側は右（既存と同じ）
      const dir = (c.centroid.x < centerX) ? +1 : -1;

      const pad = 6;
      const aabb = {
        minX: c.aabb.minX - pad,
        minY: c.aabb.minY - pad,
        maxX: c.aabb.maxX + pad,
        maxY: c.aabb.maxY + pad,
      };

      const w = Math.max(10, aabb.maxX - aabb.minX);
      const h = Math.max(10, aabb.maxY - aabb.minY);
      const sensor = Bodies.rectangle(
        (aabb.minX+aabb.maxX)/2,
        (aabb.minY+aabb.maxY)/2,
        w, h,
        { isStatic:true, isSensor:true,
          render:{ fillStyle:"rgba(255,255,0,0.12)", strokeStyle:"rgba(255,255,0,0.55)", lineWidth:1 }
        }
      );
      sensor.label = "springSensor";

      springs.push({
        sensor,
        center: { x: c.centroid.x, y: c.centroid.y },
        dir,
        cooldownUntil: 0,
        aabb
      });
    }
    World.add(engine.world, springs.map(s=>s.sensor));
  }

  function addTerrainFromBlack(blackMask){
    const boundaryPts = extractBoundaryPoints(blackMask, mapW, mapH);
    const segs = pointsToSegmentsApprox(boundaryPts, 6);

    const bodies = [];
    for (const seg of segs){
      const b = segmentToBody(Matter, seg, 4, {
        render: { fillStyle: "#222" }
      });
      b.label = "terrain";
      bodies.push(b);
    }
    World.add(engine.world, bodies);
    return { boundaryPtsCount: boundaryPts.length, segCount: segs.length };
  }

  function findSpawnFromGreen(greenComps){
    if (greenComps.length === 0) return {x:100,y:100};
    return { x: greenComps[0].centroid.x, y: greenComps[0].centroid.y };
  }

  function currentTimeSec(){ return performance.now() / 1000; }

  function coinInsideSpring(spring){
    const p = coin.position;
    const a = spring.aabb;
    return (p.x >= a.minX && p.x <= a.maxX && p.y >= a.minY && p.y <= a.maxY);
  }

  function nearestAvailableSpring(){
    let best=null, bestD2=Infinity;
    for (const s of springs){
      if (!coinInsideSpring(s)) continue;
      const dx = coin.position.x - s.center.x;
      const dy = coin.position.y - s.center.y;
      const d2 = dx*dx+dy*dy;
      if (d2 < bestD2) { bestD2=d2; best=s; }
    }
    return best;
  }

  function launchFromSpring(s, power01){
    const now = currentTimeSec();
    if (now < s.cooldownUntil) return;
    if (!touchingGround) return; // 空中発動禁止（要望の“解除”前提を維持）

    const maxImpulse = parseFloat(maxImpulseInput.value) || 18;
    const verticalBias = parseFloat(verticalBiasInput.value) || 0.22;

    const impulse = maxImpulse * Math.max(0, Math.min(1, power01));

    Body.setVelocity(coin, { x: s.dir * impulse, y: -impulse * verticalBias });
    Body.setAngularVelocity(coin, 0);

    s.cooldownUntil = now + 0.3;
  }

  // ---- レバーUI作成＆更新 ----
  function ensureLever(){
    if (leverEl) return leverEl;

    leverEl = document.createElement("div");
    leverEl.className = "lever";
    leverEl.style.display = "none";

    leverEl.innerHTML = `
      <div class="title">
        <div>レバー（バネ）</div>
        <div class="badge" id="leverDir"></div>
      </div>

      <div class="pullArea" id="pullArea">
        <div class="pullFill" id="pullFill"></div>
        <div class="pullKnob" id="pullKnob"></div>
      </div>

      <div class="mini">
        <div class="badge" id="leverPow">0%</div>
        <div class="badge" id="leverMax">READY</div>
      </div>

      <div class="sub">
        クリックして横に引っ張って溜める → 離した瞬間に発射
      </div>
    `;

    elWorld.appendChild(leverEl);

    const pullArea = leverEl.querySelector("#pullArea");
    pullArea.addEventListener("pointerdown", (e) => {
      if (!leverState.spring) return;
      leverState.dragging = true;
      leverState.pointerId = e.pointerId;
      pullArea.setPointerCapture(e.pointerId);

      leverState.startX = e.clientX;
      leverState.currentX = e.clientX;
    });

    pullArea.addEventListener("pointermove", (e) => {
      if (!leverState.dragging) return;
      if (leverState.pointerId !== e.pointerId) return;
      leverState.currentX = e.clientX;
    });

    function release(e){
      if (!leverState.dragging) return;
      if (leverState.pointerId !== e.pointerId) return;

      leverState.dragging = false;

      const s = leverState.spring;
      const power01 = leverState.power01;

      // “喋った瞬間に解除”の代わり：離した瞬間に解除して発射
      launchFromSpring(s, power01);

      // 溜めをリセット（見た目も戻す）
      leverState.power01 = 0;
      updateLeverUI();
    }

    pullArea.addEventListener("pointerup", release);
    pullArea.addEventListener("pointercancel", release);

    return leverEl;
  }

  function updateLeverPlacement(spring){
    // 画面内（canvasの表示スケールを考慮して）黄色の横に出す
    ensureLever();

    const canvas = render.canvas;
    const canvasRect = canvas.getBoundingClientRect();

    // canvasのCSS縮尺からワールド→画面への変換係数
    const sx = canvasRect.width / mapW;
    const sy = canvasRect.height / mapH;

    // ワールド座標→画面座標（canvas左上基準）
    const px = spring.center.x * sx;
    const py = spring.center.y * sy;

    // worldコンテナ内のcanvasの配置（中央寄せしてるので、その分のオフセットが必要）
    const worldRect = elWorld.getBoundingClientRect();
    const canvasLeftInWorld = canvasRect.left - worldRect.left;
    const canvasTopInWorld  = canvasRect.top  - worldRect.top;

    const baseX = canvasLeftInWorld + px;
    const baseY = canvasTopInWorld + py;

    const offsetX = (spring.dir > 0) ? 60 : -260; // 右へ打つなら右側にUI、左へ打つなら左側にUI
    const offsetY = -40;

    leverEl.style.left = (baseX + offsetX) + "px";
    leverEl.style.top  = (baseY + offsetY) + "px";
  }

  function updateLeverUI(){
    if (!leverEl) return;

    const powPct = Math.round(leverState.power01 * 100);
    const fill = leverEl.querySelector("#pullFill");
    const knob = leverEl.querySelector("#pullKnob");
    const pow = leverEl.querySelector("#leverPow");
    const max = leverEl.querySelector("#leverMax");
    const dir = leverEl.querySelector("#leverDir");

    fill.style.width = powPct + "%";
    knob.style.left = powPct + "%";
    pow.textContent = powPct + "%";

    const isMax = leverState.power01 >= 0.98;
    max.textContent = isMax ? "MAX" : (leverState.dragging ? "CHARGING" : "READY");
    max.classList.toggle("max", isMax);

    if (leverState.spring){
      dir.textContent = (leverState.spring.dir > 0) ? "→ 右へ" : "← 左へ";
    } else {
      dir.textContent = "-";
    }
  }

  function showLeverForSpring(s){
    ensureLever();
    leverState.visible = true;
    leverState.spring = s;
    leverEl.style.display = "block";
    updateLeverPlacement(s);
    updateLeverUI();
  }

  function hideLever(){
    if (!leverEl) return;
    leverEl.style.display = "none";
    leverState.visible = false;
    leverState.spring = null;
    leverState.dragging = false;
    leverState.power01 = 0;
    updateLeverUI();
  }

  function installEvents(){
    Events.on(engine, "collisionActive", (ev) => {
      touchingGround = false;
      lastGroundNormal = null;

      for (const pair of ev.pairs){
        const a = pair.bodyA, b = pair.bodyB;

        if ((a === coin && b.label==="hole") || (b === coin && a.label==="hole")){
          respawn();
          continue;
        }

        const isTerrainContact =
          (a === coin && b.label==="terrain") || (b === coin && a.label==="terrain");
        if (isTerrainContact){
          touchingGround = true;
          lastGroundNormal = pair.collision.normal;
        }
      }
    });

    Events.on(engine, "afterUpdate", () => {
      if (!coin) return;

      // レバー：コインが黄色内なら表示（最寄り）
      const s = nearestAvailableSpring();
      if (s){
        // 位置追従
        showLeverForSpring(s);
      } else {
        hideLever();
      }

      // レバーのチャージ量計算（横に引っ張る）
      if (leverState.visible && leverState.spring){
        if (leverState.dragging){
          const maxPull = Math.max(30, parseFloat(maxPullInput.value) || 150);
          const dx = leverState.currentX - leverState.startX;
          const dist = Math.min(maxPull, Math.max(0, Math.abs(dx)));

          leverState.power01 = dist / maxPull;
          updateLeverUI();
        }
        // 位置も随時更新（ウィンドウサイズ変更などに対応）
        updateLeverPlacement(leverState.spring);
      }

      const sp = coin.speed.toFixed(2);
      const av = coin.angularVelocity.toFixed(3);

      setStatus([
        `map: ${mapW}x${mapH}`,
        `coin: r=${(parseFloat(coinRInput.value)||32)} speed=${sp} angVel=${av}`,
        `touchingGround: ${touchingGround}`,
        `springs: ${springs.length}, holes: ${holes.length}`,
        leverState.visible
          ? `lever: power=${Math.round(leverState.power01*100)}% dragging=${leverState.dragging}`
          : `lever: -`
      ]);

      // 嘘静止摩擦
      if (!touchingGround || !lastGroundNormal) return;

      const n = lastGroundNormal;
      const t = { x: -n.y, y: n.x };
      const v = coin.velocity;
      const vt = v.x*t.x + v.y*t.y;

      const slopeMeasure = Math.abs(n.x);

      if (Math.abs(vt) < 0.15 && Math.abs(coin.angularVelocity) < 0.02 && slopeMeasure < 0.25){
        Body.setVelocity(coin, { x: 0, y: v.y });
        Body.setAngularVelocity(coin, 0);
      } else {
        const damp = (slopeMeasure < 0.25) ? 0.985 : 0.992;
        const vt2 = vt * damp;
        const dv = vt2 - vt;
        Body.setVelocity(coin, { x: v.x + t.x*dv, y: v.y + t.y*dv });
      }
    });

    // 黄色範囲の可視化（任意）
    Events.on(render, "afterRender", () => {
      const context = render.context;
      if (!coin) return;

      for (const s of springs){
        if (!coinInsideSpring(s)) continue;

        context.save();
        context.strokeStyle = "rgba(255, 255, 0, 0.55)";
        context.lineWidth = 3;
        context.setLineDash([10, 6]);
        const a = s.aabb;
        context.strokeRect(a.minX, a.minY, a.maxX - a.minX, a.maxY - a.minY);
        context.setLineDash([]);

        context.fillStyle = "rgba(255, 255, 0, 0.85)";
        context.font = "bold 16px sans-serif";
        context.textAlign = "center";
        context.fillText(s.dir > 0 ? "→" : "←", s.center.x, s.center.y - 28);

        context.restore();
      }
    });
  }

  async function rebuild(){
    destroyWorld();
    setStatus(["loading ren.png..."]);

    renImage = await loadRenPng();
    buildRenImageData(renImage);

    createEngineAndRenderer();

    const {black, red, green, yellow} = buildMasks();
    const greenComps = extractComponents(green, mapW, mapH);
    const redComps = extractComponents(red, mapW, mapH);
    const yellowComps = extractComponents(yellow, mapW, mapH);

    spawnPoint = findSpawnFromGreen(greenComps);
    const terrainInfo = addTerrainFromBlack(black);

    addHolesFromComponents(redComps);
    addSpringsFromComponents(yellowComps);
    addCoin();

    installEvents();

    setStatus([
      `map: ${mapW}x${mapH}`,
      `spawn: (${spawnPoint.x.toFixed(1)}, ${spawnPoint.y.toFixed(1)})`,
      `terrain boundaryPts=${terrainInfo.boundaryPtsCount} segs=${terrainInfo.segCount}`,
      `holes=${redComps.length} springs=${Math.min(6, yellowComps.length)}`,
      `ready`
    ]);
  }

  reloadBtn.addEventListener("click", () => rebuild());
  respawnBtn.addEventListener("click", () => respawn());
  gravityYInput.addEventListener("change", () => { if(engine) engine.gravity.y = parseFloat(gravityYInput.value)||1; });

  rebuild().catch(err => {
    console.error(err);
    setStatus(["ERROR:", String(err)]);
  });
})();
</script>
</body>
</html>
