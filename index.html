<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ゲーム選択</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#120a06;
      --panel:#1a0f08;
      --border:#5a2a10;
      --text:#ffe9d6;
      --muted:#ffbf8a;
      --accent:#ff5a1f;
      --accent2:#ffb300;
      --good:#3dff7a;
      --bad:#ff3d3d;
      --ink:#0b0706;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow:hidden;}
    *{box-sizing:border-box;}

    /* layout */
    #app{
      height:100vh;
      display:grid;
      grid-template-columns: 360px 1fr;
    }
    #side{
      border-right: 2px solid var(--border);
      background: linear-gradient(180deg, rgba(255,90,31,0.08), rgba(0,0,0,0)) , var(--panel);
      padding: 14px;
      overflow:auto;
    }
    #main{
      position:relative;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }
    #main canvas{max-width:100%; max-height:100%; width:auto; height:auto; display:block; background:#000;}

    /* panels */
    .card{
      border:2px solid var(--border);
      background: rgba(0,0,0,0.25);
      border-radius: 14px;
      padding: 12px;
      margin: 10px 0;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }
    h1{margin:0 0 10px; font-size: 16px; letter-spacing: 0.03em;}
    .row{margin:10px 0;}
    .label{font-size:12px; color:var(--muted); margin-bottom:6px;}
    input[type="text"], input[type="password"], input[type="number"]{
      width:100%;
      padding:10px 10px;
      border-radius: 10px;
      border:2px solid rgba(255,180,90,0.25);
      background: rgba(0,0,0,0.35);
      color: var(--text);
      outline:none;
    }
    input:focus{border-color: rgba(255,90,31,0.7);}
    button{
      width:100%;
      padding: 10px 10px;
      border-radius: 12px;
      border: 2px solid rgba(255,180,90,0.25);
      background: linear-gradient(180deg, rgba(255,90,31,0.28), rgba(0,0,0,0.25));
      color: var(--text);
      cursor:pointer;
      font-weight: 700;
    }
    button:hover{border-color: rgba(255,90,31,0.7);}
    button:disabled{opacity:0.45; cursor:not-allowed;}

    .split{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    .tiny{font-size:11px; color:rgba(255,233,214,0.75); line-height:1.45;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; white-space:pre-wrap;}
    .badge{
      display:inline-block;
      padding:3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.25);
      font-size: 11px;
    }
    .badge.good{border-color: rgba(61,255,122,0.55); color: var(--good);}
    .badge.bad{border-color: rgba(255,61,61,0.55); color: var(--bad);}

    /* Lever UI */
    #leverCard .title{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      color: var(--accent2);
      font-size: 12px;
      margin-bottom: 8px;
      font-weight: 800;
    }
    #pullArea{
      height: 44px;
      border-radius: 12px;
      border: 2px solid rgba(255,180,90,0.25);
      background: rgba(0,0,0,0.35);
      position: relative;
      overflow:hidden;
      user-select:none;
      touch-action:none;
      cursor: grab;
    }
    #pullArea:active{ cursor: grabbing; }
    #pullFill{
      position:absolute; left:0; top:0; bottom:0;
      width:0%;
      background: linear-gradient(90deg, #20ff70, #ffee55, #ff8a22, #ff2a2a);
      opacity: 0.9;
    }
    #pullKnob{
      position:absolute;
      top: 50%;
      transform: translate(-50%,-50%);
      width: 18px; height: 18px; border-radius: 999px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 2px 10px rgba(0,0,0,0.55);
      left: 0%;
    }

    /* clear overlay */
    #clearOverlay{
      position:absolute; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.65);
      z-index: 10;
    }
    #clearOverlay img{
      max-width: min(520px, 80vw);
      max-height: min(520px, 80vh);
      border-radius: 20px;
      border: 3px solid rgba(255,180,90,0.35);
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      background:#000;
    }
  </style>
</head>
<body>
<div id="app">
  <aside id="side">
    <h1>ゲーム</h1>

    <!-- 0) Game select -->
    <div class="card" id="screenGameSelect">
      <div class="label">ゲーム選択</div>
      <div class="split">
        <button id="btnJanken" disabled>じゃんけん（未実装）</button>
        <button id="btnTenyen">10円ゲーム</button>
      </div>
      <div class="tiny" style="margin-top:8px;">
        10円ゲームは「プ���イは1人だけ / それ以外は観戦」。
      </div>
    </div>

    <!-- 1) Name input -->
    <div class="card" id="screenName" style="display:none;">
      <div class="label">名前入力（空欄なら匿名）</div>
      <input id="nameInput" type="text" maxlength="16" placeholder="例：たろう">
      <div class="row">
        <button id="btnNameOk">決定</button>
      </div>
      <div class="tiny">
        ※この名前が「プレイ中の人」「待機中の人」に表示されます。
      </div>
    </div>

    <!-- 2) Ten yen main UI -->
    <div class="card" id="screenTenyen" style="display:none;">
      <div class="row">
        <div class="label">状態</div>
        <div id="roomStatus" class="mono">loading...</div>
      </div>

      <!-- Play control -->
      <div class="row split">
        <button id="btnPlay">プレイする</button>
        <button id="btnEnd" disabled>終わる</button>
      </div>

      <div class="row split">
        <button id="btnBack" disabled>戻る（新しく生成）</button>
        <button id="btnReset" disabled>10円リセット</button>
      </div>

      <!-- Spectator waiting -->
      <div class="row" id="waitCard">
        <div class="label">観戦者：待機</div>
        <button id="btnWait">待機する</button>
        <div class="tiny">待機すると名前が表示されます（10分おきに更新）。プレイ開始で自動的に消えます。</div>
        <div class="row">
          <div class="label">待機中</div>
          <div id="waitList" class="mono">(none)</div>
        </div>
      </div>

      <!-- Lever always visible -->
      <div class="row card" id="leverCard" style="margin:0;">
        <div class="title">
          <div>レバー（引いて→離す）</div>
          <div id="leverBadge" class="badge">OFF</div>
        </div>
        <div id="pullArea">
          <div id="pullFill"></div>
          <div id="pullKnob"></div>
        </div>
        <div class="row" style="display:flex; justify-content:space-between; gap:8px;">
          <span class="badge" id="powChip">0%</span>
          <span class="badge" id="dirChip">dir:-</span>
        </div>
        <div class="tiny">
          プレイ中のみ操作できます。<br>
          右の黄色→左 / 左の黄色→右。map.pngは全員に表示。
        </div>
      </div>

      <!-- Admin mode -->
      <div class="row card" id="adminCard" style="margin-top:10px;">
        <div class="label">運営モード（password: 1122）</div>
        <input id="adminPass" type="password" placeholder="1122">
        <div class="row split">
          <button id="adminEnter">決定</button>
          <button id="adminExit" style="display:none;">退出</button>
        </div>
        <div id="adminMsg" class="tiny"></div>

        <div id="adminPanel" style="display:none; margin-top:10px;">
          <div class="label">運営設定</div>
          <div class="row split">
            <div>
              <div class="label">maxImpulse（内部x1.5）</div>
              <input id="maxImpulse" type="number" value="18" min="1" max="200">
            </div>
            <div>
              <div class="label">nearDist</div>
              <input id="nearDist" type="number" value="180" min="20" max="1000">
            </div>
          </div>

          <div class="row split">
            <div>
              <div class="label">maxPull</div>
              <input id="maxPull" type="number" value="150" min="40" max="600">
            </div>
            <div>
              <div class="label">cooldown(s)</div>
              <input id="cooldown" type="number" value="0.30" step="0.05" min="0" max="2">
            </div>
          </div>

          <div class="row split">
            <div>
              <div class="label">gravityY</div>
              <input id="gravityY" type="number" value="1" step="0.1" min="0" max="5">
            </div>
            <div>
              <div class="label">slopeProbe</div>
              <input id="slopeProbe" type="number" value="34" step="2" min="6" max="200">
            </div>
          </div>

          <div class="row split">
            <div>
              <div class="label">slopeAssist（内部さらに強化）</div>
              <input id="slopeAssist" type="number" value="2.3" step="0.1" min="0" max="20">
            </div>
            <div>
              <div class="label">coinR</div>
              <input id="coinR" type="number" value="32" min="4" max="128">
            </div>
          </div>

          <div class="row split">
            <div>
              <div class="label">smoothIters</div>
              <input id="smoothIters" type="number" value="2" min="0" max="6">
            </div>
            <div>
              <div class="label">smoothThresh</div>
              <input id="smoothThresh" type="number" value="0.58" step="0.01" min="0.5" max="0.9">
            </div>
          </div>

          <div class="row split">
            <button id="btnRebuild">再生成</button>
            <button id="btnAnnounce">観戦者へ軽いアナウンス</button>
          </div>

          <div class="tiny">
            通常表示は「map + 10円 + 黄色枠」。運営時のみ赤/青などもオーバーレイ表示。
          </div>
        </div>
      </div>
    </div>
  </aside>

  <main id="main">
    <div id="clearOverlay"><img id="clearImg" src="krg.png" alt="clear"></div>
  </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>

<script type="module">
  // ==========================
  // Firebase 初期化
  // ==========================
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-analytics.js";
  import {
    getDatabase,
    ref,
    onValue,
    set,
    update,
    remove,
    serverTimestamp,
    onDisconnect,
  } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCC7KAv7V4j1Z6-o1Y8ikmb3r5htN9O_aA",
    authDomain: "zzgohan-280.firebaseapp.com",
    databaseURL: "https://zzgohan-280-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "zzgohan-280",
    storageBucket: "zzgohan-280.firebasestorage.app",
    messagingSenderId: "459336048542",
    appId: "1:459336048542:web:ff6c825dec81cc7df8008f",
    measurementId: "G-JX4RP9LWR3"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const db = getDatabase(app);

  // ==========================
  // Utilities / state
  // ==========================
  const ROOM_PATH = "rooms/tenyen/main";
  const stateRef = ref(db, `${ROOM_PATH}/state`);
  const waitRef = ref(db, `${ROOM_PATH}/waiting`);
  const announceRef = ref(db, `${ROOM_PATH}/announce`); // optional

  const clientId = (() => {
    const k = "tenyen_client_id";
    let v = localStorage.getItem(k);
    if (!v){
      v = crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2);
      localStorage.setItem(k, v);
    }
    return v;
  })();

  let myName = "匿名";
  let adminMode = false;

  const $ = (id)=>document.getElementById(id);

  function setVisible(id, visible){
    const el = $(id);
    if (el) el.style.display = visible ? "" : "none";
  }

  // ==========================
  // Screens
  // ==========================
  function showScreen(which){
    setVisible("screenGameSelect", which==="select");
    setVisible("screenName", which==="name");
    setVisible("screenTenyen", which==="tenyen");
  }

  $("btnTenyen").addEventListener("click", ()=> showScreen("name"));
  $("btnNameOk").addEventListener("click", ()=>{
    const v = $("nameInput").value.trim();
    myName = v ? v : "匿名";
    showScreen("tenyen");
    ensureLoadedOnce();
  });

  // ==========================
  // Audio (unlock + play)
  // ==========================
  const sounds = {
    fail: new Audio("s.mp3"),
    shot: new Audio("u.mp3"),
    hit:  new Audio("b.mp3"),
    spawn:new Audio("t.mp3"),
    clear:new Audio("kr.mp3"),
  };
  for (const a of Object.values(sounds)){
    a.preload = "auto";
    a.volume = 0.9;
  }
  let audioUnlocked = false;
  async function unlockAudioOnce(){
    if (audioUnlocked) return;
    audioUnlocked = true;
    try{
      const a = sounds.spawn;
      const prev = a.volume;
      a.volume = 0;
      a.currentTime = 0;
      await a.play();
      a.pause();
      a.currentTime = 0;
      a.volume = prev;
    }catch(e){}
  }
  function playSound(key){
    const a = sounds[key];
    if (!a) return;
    try{
      a.pause();
      a.currentTime = 0;
      a.play().catch(()=>{});
    }catch(e){}
  }

  // ==========================
  // Game assets
  // ==========================
  const REN_URL = "ren.png";
  const MAP_URL = "map.png";
  const COIN_IMG_URL = "10.png";

  // draw coin image circular clip
  const coinTexture = {
    img: null,
    ready: false,
    patternCanvas: null,
    load: async ()=>{
      if (coinTexture.ready) return;
      const img = new Image();
      img.src = COIN_IMG_URL + "?t=" + Date.now();
      await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; });
      coinTexture.img = img;
      coinTexture.ready = true;
    }
  };

  // ==========================
  // Ten yen game core (Matter.js)
  // ==========================
  const Matter = window.Matter;
  const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

  let engine=null, render=null, runner=null;
  let renCanvas=null, renCtx=null, renData=null;
  let mapW=0, mapH=0;

  let coin=null;
  let spawnPoint={x:100,y:100};

  let holes=[];
  let goals=[];
  let springs=[];
  let blackMaskGlobal=null;

  let touchingGround=false;
  let lastGroundNormal=null;

  // lever state (local UI)
  let lever = { enabled:false, activeSpring:null, dragging:false, pointerId:null, startX:0, currentX:0, pullRatio:0 };

  // show restriction:
  // - spectator/player: map + coin + yellow frames
  // - admin: overlays red/blue (still no terrain lines)
  const overlay = {
    showAdmin: ()=> adminMode
  };

  // Tuning constants requested previously
  const UPWARD_BIAS_FIXED = 0; // y component = 0
  const IMPULSE_MULT = 1.5;

  // slope assist: stronger + stuck boost
  const SLOPE_ACCEL_MULT = 2.0;
  const SLOPE_EXTRA_MULT = 2.6;     // stronger than earlier
  const STUCK_BOOST_MULT = 3.8;     // stronger stuck help
  const STUCK_SPEED_TH = 0.22;
  const MIN_SIN_TO_APPLY = 0.015;

  // strong hit sound
  let lastHitAt = 0;
  const HIT_COOLDOWN_MS = 130;
  const HIT_SPEED_TH = 7.0;

  // input timeout
  const IDLE_TIMEOUT_MS = 60_000;

  // waiting refresh
  const WAIT_REFRESH_MS = 10 * 60_000;

  // ==========================
  // Mask classify (ren.png)
  // ==========================
  function classifyPixel(r,g,b,a){
    if (a < 10) return "empty";
    if (r < 40 && g < 40 && b < 40) return "black";
    if (r > 180 && g < 80 && b < 80) return "red";
    if (g > 160 && r < 120 && b < 120) return "green";
    if (r > 180 && g > 180 && b < 120) return "yellow";
    if (b > 180 && r < 100 && g < 140) return "blue";
    return "empty";
  }

  function extractComponents(mask, w, h){
    const visited = new Uint8Array(w*h);
    const comps = [];
    const qx = new Int32Array(w*h);
    const qy = new Int32Array(w*h);
    const idx = (x,y)=>y*w+x;
    const push = (x,y,tail)=>{ qx[tail]=x; qy[tail]=y; return tail+1; };

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = idx(x,y);
        if (!mask[i] || visited[i]) continue;

        let head=0, tail=0;
        tail = push(x,y,tail);
        visited[i]=1;

        let sumX=0, sumY=0, area=0;
        let minX=x, minY=y, maxX=x, maxY=y;

        while(head<tail){
          const cx=qx[head], cy=qy[head]; head++;
          area++;
          sumX += cx; sumY += cy;
          if (cx<minX) minX=cx; if (cy<minY) minY=cy;
          if (cx>maxX) maxX=cx; if (cy>maxY) maxY=cy;

          const n1 = (cx>0)   ? idx(cx-1,cy) : -1;
          const n2 = (cx<w-1) ? idx(cx+1,cy) : -1;
          const n3 = (cy>0)   ? idx(cx,cy-1) : -1;
          const n4 = (cy<h-1) ? idx(cx,cy+1) : -1;

          if (n1>=0 && mask[n1] && !visited[n1]){ visited[n1]=1; tail=push(cx-1,cy,tail); }
          if (n2>=0 && mask[n2] && !visited[n2]){ visited[n2]=1; tail=push(cx+1,cy,tail); }
          if (n3>=0 && mask[n3] && !visited[n3]){ visited[n3]=1; tail=push(cx,cy-1,tail); }
          if (n4>=0 && mask[n4] && !visited[n4]){ visited[n4]=1; tail=push(cx,cy+1,tail); }
        }

        comps.push({ area, centroid:{x:sumX/area,y:sumY/area}, aabb:{minX,minY,maxX,maxY} });
      }
    }
    comps.sort((a,b)=>b.area-a.area);
    return comps;
  }

  function smoothBinaryMask(mask, w, h, iters=2, threshold=0.58){
    let src = mask;
    let dst = new Uint8Array(w*h);
    const idx = (x,y)=>y*w+x;
    for (let iter=0; iter<iters; iter++){
      dst.fill(0);
      for (let y=1; y<h-1; y++){
        for (let x=1; x<w-1; x++){
          let count = 0;
          count += src[idx(x-1,y-1)];
          count += src[idx(x  ,y-1)];
          count += src[idx(x+1,y-1)];
          count += src[idx(x-1,y  )];
          count += src[idx(x  ,y  )];
          count += src[idx(x+1,y  )];
          count += src[idx(x-1,y+1)];
          count += src[idx(x  ,y+1)];
          count += src[idx(x+1,y+1)];
          dst[idx(x,y)] = (count/9 >= threshold) ? 1 : 0;
        }
      }
      for (let x=0;x<w;x++){ dst[idx(x,0)] = src[idx(x,0)]; dst[idx(x,h-1)] = src[idx(x,h-1)]; }
      for (let y=0;y<h;y++){ dst[idx(0,y)] = src[idx(0,y)]; dst[idx(w-1,y)] = src[idx(w-1,y)]; }
      const tmp = src; src = dst; dst = tmp;
    }
    return src;
  }

  function extractBoundaryPoints(blackMask, w, h){
    const pts = [];
    const idx = (x,y)=>y*w+x;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i = idx(x,y);
        if (!blackMask[i]) continue;
        if (!blackMask[idx(x-1,y)] || !blackMask[idx(x+1,y)] || !blackMask[idx(x,y-1)] || !blackMask[idx(x,y+1)]) {
          pts.push({x,y});
        }
      }
    }
    return pts;
  }

  function pointsToSegmentsApproxSmooth(points, sampleStep=6, grid=2){
    const segs = [];
    const snap = (v)=>Math.round(v / grid) * grid;
    const pts = [];
    for (let i=0; i<points.length; i+=sampleStep){
      const p = points[i];
      pts.push({ x: snap(p.x), y: snap(p.y) });
    }
    const maxD2 = (sampleStep*sampleStep*20);
    const minD2 = 4;

    for (let i=0; i<pts.length; i++){
      const p = pts[i];
      let bestJ = -1;
      let bestD2 = Infinity;
      for (let j=i+1; j<Math.min(pts.length, i+220); j++){
        const q = pts[j];
        const dx=q.x-p.x, dy=q.y-p.y;
        const d2=dx*dx+dy*dy;
        if (d2 < minD2) continue;
        if (d2 < bestD2 && d2 < maxD2){
          bestD2 = d2;
          bestJ = j;
        }
      }
      if (bestJ >= 0){
        const q = pts[bestJ];
        segs.push({x1:p.x,y1:p.y,x2:q.x,y2:q.y});
      }
    }
    return segs;
  }

  function segmentToBody(seg, thickness=6){
    const { Bodies } = Matter;
    const x1=seg.x1, y1=seg.y1, x2=seg.x2, y2=seg.y2;
    const mx=(x1+x2)/2, my=(y1+y2)/2;
    const dx=x2-x1, dy=y2-y1;
    const len=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx);
    return Bodies.rectangle(mx, my, len, thickness, {
      isStatic:true,
      friction: 0.52,
      restitution: 0,
      angle: ang,
      render: { visible: false }
    });
  }

  async function loadImage(url){
    const img = new Image();
    img.src = url + "?t=" + Date.now();
    await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; });
    return img;
  }

  async function loadRenAndMasks(){
    const renImg = await loadImage(REN_URL);
    mapW = renImg.naturalWidth || renImg.width;
    mapH = renImg.naturalHeight || renImg.height;

    renCanvas = document.createElement("canvas");
    renCanvas.width = mapW;
    renCanvas.height = mapH;
    renCtx = renCanvas.getContext("2d", { willReadFrequently:true });
    renCtx.drawImage(renImg, 0, 0);
    renData = renCtx.getImageData(0,0,mapW,mapH);

    const data=renData.data;
    const black = new Uint8Array(mapW*mapH);
    const red   = new Uint8Array(mapW*mapH);
    const green = new Uint8Array(mapW*mapH);
    const yellow= new Uint8Array(mapW*mapH);
    const blue  = new Uint8Array(mapW*mapH);

    for(let y=0;y<mapH;y++){
      for(let x=0;x<mapW;x++){
        const i = (y*mapW+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        const c = classifyPixel(r,g,b,a);
        const p = y*mapW+x;
        if (c==="black") black[p]=1;
        else if (c==="red") red[p]=1;
        else if (c==="green") green[p]=1;
        else if (c==="yellow") yellow[p]=1;
        else if (c==="blue") blue[p]=1;
      }
    }
    return {black, red, green, yellow, blue};
  }

  function resizeCanvasToFit(){
    if (!render) return;
    const canvas = render.canvas;
    const rect = $("main").getBoundingClientRect();
    const scale = Math.min(rect.width / mapW, rect.height / mapH);
    canvas.style.width = (mapW * scale) + "px";
    canvas.style.height = (mapH * scale) + "px";
  }

  function setBackground(url){
    render.options.background = `url(${url})`;
    render.canvas.style.backgroundImage = `url(${url})`;
    render.canvas.style.backgroundSize = "100% 100%";
    render.canvas.style.backgroundRepeat = "no-repeat";
    render.canvas.style.backgroundPosition = "0 0";
  }

  function coinRender(ctx){
    if (!coinTexture.ready || !coinTexture.img) return;

    // Matter.Render はデフォルトでボディ描画するが、
    // ここでは coin.body を透明にして afterRender で画像を上描きする
    const img = coinTexture.img;

    ctx.save();
    ctx.translate(coin.position.x, coin.position.y);
    ctx.rotate(coin.angle);

    // 円形クリップ（正方形画像を円で切り抜く）
    const r = coin.circleRadius;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI*2);
    ctx.clip();

    // 画像を円に収める（正方形を r*2 にフィット）
    ctx.drawImage(img, -r, -r, r*2, r*2);

    // 縁取り
    ctx.restore();
    ctx.save();
    ctx.translate(coin.position.x, coin.position.y);
    ctx.beginPath();
    ctx.arc(0, 0, coin.circleRadius, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.restore();
  }

  function drawYellowFrames(ctx){
    for (const s of springs){
      const active = (s === lever.activeSpring);
      ctx.save();
      ctx.strokeStyle = active ? "rgba(255,220,80,0.95)" : "rgba(255,255,0,0.55)";
      ctx.lineWidth = active ? 4 : 3;
      const a = s.aabb;
      ctx.strokeRect(a.minX, a.minY, a.maxX-a.minX, a.maxY-a.minY);
      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = active ? "rgba(255,220,80,0.95)" : "rgba(255,255,0,0.7)";
      ctx.fillText(s.dir > 0 ? "→" : "←", s.center.x, s.center.y - 22);
      ctx.restore();
    }
  }

  function drawAdminOverlays(ctx){
    // red holes
    ctx.save();
    for (const h of holes){
      ctx.beginPath();
      ctx.arc(h.position.x, h.position.y, h.circleRadius, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,0,0,0.18)";
      ctx.fill();
      ctx.strokeStyle = "rgba(255,0,0,0.6)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    // blue goals
    for (const g of goals){
      ctx.beginPath();
      ctx.arc(g.position.x, g.position.y, g.circleRadius, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,160,255,0.18)";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,160,255,0.7)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  function coinInsideSpring(s){
    const p = coin.position;
    const a = s.aabb;
    return (p.x >= a.minX && p.x <= a.maxX && p.y >= a.minY && p.y <= a.maxY);
  }

  function nearestSpringByDistance(){
    const nearDist = adminMode ? getNum("nearDist", 180) : getNum("nearDist", 180);
    let best=null, bestD2=Infinity;
    for (const s of springs){
      const dx = coin.position.x - s.center.x;
      const dy = coin.position.y - s.center.y;
      const d2 = dx*dx + dy*dy;
      const near = coinInsideSpring(s) || (d2 <= nearDist*nearDist);
      if (!near) continue;
      if (d2 < bestD2){ bestD2 = d2; best = s; }
    }
    return best;
  }

  function canOperateLever(){
    return localRole.isPlayer && localRole.playing && lever.enabled && touchingGround;
  }

  function setLeverUI(enabled, pullRatio, spring){
    lever.enabled = enabled;
    lever.activeSpring = spring;
    const pct = Math.round(pullRatio * 100);
    $("pullFill").style.width = pct + "%";
    $("pullKnob").style.left = pct + "%";
    $("powChip").textContent = pct + "%";
    if (!enabled){
      $("leverBadge").textContent = "OFF";
      $("dirChip").textContent = "dir:-";
      $("pullArea").style.opacity = "0.45";
      return;
    }
    $("pullArea").style.opacity = "1";
    $("leverBadge").textContent = lever.dragging ? "CHARGING" : "READY";
    $("dirChip").textContent = spring ? (spring.dir > 0 ? "dir:→(右)" : "dir:←(左)") : "dir:-";
  }

  function getNum(id, fallback){
    const el = $(id);
    if (!el) return fallback;
    const v = parseFloat(el.value);
    return Number.isFinite(v) ? v : fallback;
  }

  function isBlackAt(x,y){
    if (!blackMaskGlobal) return false;
    x = Math.max(0, Math.min(mapW-1, x|0));
    y = Math.max(0, Math.min(mapH-1, y|0));
    return blackMaskGlobal[y*mapW + x] === 1;
  }
  function findGroundY(x, startY, maxDown=140){
    const sx = x|0;
    let y = Math.max(0, Math.min(mapH-1, startY|0));
    for (let i=0;i<maxDown;i++){
      const yy = y + i;
      if (yy >= mapH) break;
      if (isBlackAt(sx, yy) && !isBlackAt(sx, yy-1)) return yy;
    }
    return null;
  }
  function estimateSlopeAtCoin(){
    const probe = getNum("slopeProbe", 34);
    const px = coin.position.x;
    const py = coin.position.y;
    const r = getNum("coinR", 32);
    const startY = py + r * 0.6;
    const xL = Math.max(0, Math.min(mapW-1, (px - probe)|0));
    const xR = Math.max(0, Math.min(mapW-1, (px + probe)|0));
    const yL = findGroundY(xL, startY, 160);
    const yR = findGroundY(xR, startY, 160);
    if (yL == null || yR == null) return null;
    const dx = xR - xL;
    if (dx <= 0) return null;
    const dy = yR - yL;
    const slope = dy / dx;
    return { slope };
  }
  function applySlopeAssist(){
    if (!touchingGround) return;
    const est = estimateSlopeAtCoin();
    if (!est) return;
    const tan = est.slope;
    const sin = tan / Math.sqrt(1 + tan*tan);
    if (Math.abs(sin) < MIN_SIN_TO_APPLY) return;

    const gMatter = engine.gravity.y;
    let assistK = getNum("slopeAssist", 2.3) * SLOPE_ACCEL_MULT * SLOPE_EXTRA_MULT;

    const speed = Math.hypot(coin.velocity.x, coin.velocity.y);
    if (speed < STUCK_SPEED_TH) assistK *= STUCK_BOOST_MULT;

    const ax = gMatter * sin * assistK;
    const dt = 0.016;
    const v = coin.velocity;
    let vx = v.x + ax * dt;

    const downhillDir = (sin > 0) ? +1 : -1;
    const minRoll = (speed < STUCK_SPEED_TH) ? 0.22 : 0.12;
    if (Math.sign(vx) === downhillDir && Math.abs(vx) < minRoll){
      vx = downhillDir * minRoll;
    }
    Body.setVelocity(coin, { x: vx, y: v.y });
  }

  // ==========================
  // Multiplayer room logic
  // ==========================
  const localRole = {
    isPlayer: false,
    playing: false,
    playerName: "",
    playerId: ""
  };

  function nowMs(){ return Date.now(); }

  async function ensureRoomInitializedOnce(){
    // If empty, set initial state
    // We do a simple set-if-null by reading once via onValue (first callback) then set if missing.
    // Avoid heavy transactions (keeps snippet simple).
    return new Promise((resolve) => {
      let done = false;
      const unsub = onValue(stateRef, async (snap) => {
        if (done) return;
        done = true;
        const v = snap.val();
        if (!v){
          await set(stateRef, {
            phase: "idle",
            player: null,
            lastInputAt: 0,
            coin: null,
            audio: null,
            clear: null,
            map: { w: 0, h: 0 }
          });
        }
        resolve();
        unsub();
      }, { onlyOnce: true });
    });
  }

  async function becomeWaiting(){
    await unlockAudioOnce();
    await set(ref(db, `${ROOM_PATH}/waiting/${clientId}`), {
      name: myName,
      updatedAt: serverTimestamp()
    });
    onDisconnect(ref(db, `${ROOM_PATH}/waiting/${clientId}`)).remove();
  }

  async function stopWaiting(){
    await remove(ref(db, `${ROOM_PATH}/waiting/${clientId}`)).catch(()=>{});
  }

  async function tryStartPlay(){
    await unlockAudioOnce();

    // crude lock: if state.player is null -> claim
    // (RTDB transaction would be better, but request asked to avoid bugs; transactions are safer,
    // however keeping it minimal: we do a "soft lock" and re-check.)
    const snap = await new Promise((resolve)=> onValue(stateRef, (s)=>resolve(s), { onlyOnce: true }));
    const st = snap.val();
    if (!st || st.phase !== "idle" || st.player){
      return false;
    }

    // claim
    await update(stateRef, {
      phase: "playing",
      player: { id: clientId, name: myName },
      lastInputAt: serverTimestamp(),
      audio: { type: "spawn", at: serverTimestamp() }
    });

    localRole.isPlayer = true;
    localRole.playing = true;
    localRole.playerId = clientId;
    localRole.playerName = myName;

    // play removes waiting
    await stopWaiting();

    // disconnect => release lock
    onDisconnect(stateRef).update({
      phase: "idle",
      player: null,
      lastInputAt: 0
    });

    return true;
  }

  async function endPlay(reason="ended"){
    if (!localRole.isPlayer) return;
    await update(stateRef, {
      phase: "idle",
      player: null,
      lastInputAt: 0,
      audio: { type: "announce", at: serverTimestamp(), reason }
    }).catch(()=>{});
    localRole.isPlayer = false;
    localRole.playing = false;
    localRole.playerId = "";
    localRole.playerName = "";
  }

  // auto-kick: spectator can help release if idle timeout exceeded
  async function enforceIdleTimeoutIfNeeded(st){
    if (!st || st.phase !== "playing" || !st.player) return;
    const last = st.lastInputAt || 0;
    // lastInputAt is serverTimestamp; depending on rules it might be object or number.
    // With RTDB serverTimestamp it becomes number ms in snapshots.
    if (typeof last !== "number") return;
    if (Date.now() - last > IDLE_TIMEOUT_MS){
      await update(stateRef, { phase:"idle", player:null, lastInputAt:0, audio:{ type:"announce", at: serverTimestamp(), reason:"timeout" } }).catch(()=>{});
    }
  }

  // 10-min waiting refresh + announcement
  let lastWaitRefreshAt = 0;
  async function refreshWaitingListIfNeeded(){
    const now = Date.now();
    if (now - lastWaitRefreshAt < WAIT_REFRESH_MS) return;
    lastWaitRefreshAt = now;

    // only spectators do this (simple)
    if (localRole.isPlayer) return;

    // refresh my waiting stamp if I am in waiting
    const myWaitSnap = await new Promise((resolve)=> onValue(ref(db, `${ROOM_PATH}/waiting/${clientId}`), (s)=>resolve(s), { onlyOnce: true }));
    if (myWaitSnap.exists()){
      await update(ref(db, `${ROOM_PATH}/waiting/${clientId}`), { updatedAt: serverTimestamp() }).catch(()=>{});
      await update(stateRef, { audio:{ type:"announce", at: serverTimestamp(), reason:"wait-refresh" } }).catch(()=>{});
    }
  }

  // ==========================
  // Buttons
  // ==========================
  $("btnWait").addEventListener("click", ()=> becomeWaiting());

  $("btnPlay").addEventListener("click", async ()=>{
    const ok = await tryStartPlay();
    if (!ok){
      alert("いまは他の人がプレイ中です。観戦できます。");
    }
  });

  $("btnEnd").addEventListener("click", async ()=>{
    await endPlay("ended");
  });

  // Back: remove current coin and respawn (player only)
  $("btnBack").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if (!localRole.isPlayer) return;
    await respawnCoinAndBroadcast(true);
  });

  $("btnReset").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if (!localRole.isPlayer) return;
    await respawnCoinAndBroadcast(false);
  });

  // Admin
  $("adminEnter").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if ($("adminPass").value === "1122"){
      adminMode = true;
      $("adminMsg").textContent = "運営モードON";
      $("adminExit").style.display = "";
      $("adminPanel").style.display = "";
      $("adminPass").value = "";
    } else {
      $("adminMsg").textContent = "パスワードが違います";
    }
  });
  $("adminExit").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    adminMode = false;
    $("adminMsg").textContent = "運営モードOFF";
    $("adminExit").style.display = "none";
    $("adminPanel").style.display = "none";
  });

  $("btnRebuild").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    await rebuildWorld(); // local only visuals; but map/coin are shared anyway
    await update(stateRef, { audio:{ type:"announce", at: serverTimestamp(), reason:"rebuild" } }).catch(()=>{});
  });
  $("btnAnnounce").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    await update(stateRef, { audio:{ type:"announce", at: serverTimestamp(), reason:"admin" } }).catch(()=>{});
  });

  // ==========================
  // Lever input
  // ==========================
  $("pullArea").addEventListener("pointerdown", async (e)=>{
    await unlockAudioOnce();
    if (!canOperateLever()) return;
    lever.dragging = true;
    lever.pointerId = e.pointerId;
    lever.startX = e.clientX;
    lever.currentX = e.clientX;
    $("pullArea").setPointerCapture(e.pointerId);
    await markPlayerInput();
  });

  $("pullArea").addEventListener("pointermove", async (e)=>{
    if (!lever.dragging) return;
    if (lever.pointerId !== e.pointerId) return;
    if (!canOperateLever()) return;

    lever.currentX = e.clientX;

    const s = lever.activeSpring;
    if (!s) return;

    const maxPull = getNum("maxPull", 150);
    const dx = lever.currentX - lever.startX;
    const pullSigned = -s.dir * dx; // reverse direction pull charges
    const pullPx = Math.max(0, Math.min(maxPull, pullSigned));
    lever.pullRatio = Math.max(0, Math.min(1, pullPx / maxPull));
    setLeverUI(true, lever.pullRatio, s);

    await markPlayerInput();
  });

  $("pullArea").addEventListener("pointerup", async (e)=>{
    if (!lever.dragging) return;
    if (lever.pointerId !== e.pointerId) return;
    lever.dragging = false;

    const s = lever.activeSpring;
    const ratio = lever.pullRatio;

    if (canOperateLever() && s && ratio > 0){
      launchFromSpring(s, ratio);
      playSound("shot");
      await broadcastAudio("shot");
      await markPlayerInput();
    }

    lever.pullRatio = 0;
    setLeverUI(lever.enabled, 0, lever.activeSpring);
  });

  $("pullArea").addEventListener("pointercancel", ()=>{
    lever.dragging = false;
    lever.pullRatio = 0;
    setLeverUI(lever.enabled, 0, lever.activeSpring);
  });

  async function markPlayerInput(){
    if (!localRole.isPlayer) return;
    await update(stateRef, { lastInputAt: serverTimestamp() }).catch(()=>{});
  }

  async function broadcastAudio(type){
    await update(stateRef, { audio: { type, at: serverTimestamp() } }).catch(()=>{});
  }

  // ==========================
  // Physics actions
  // ==========================
  function launchFromSpring(s, pullRatio){
    const now = performance.now()/1000;
    if (now < (s.cooldownUntil||0)) return;
    if (!touchingGround) return;

    const maxImpulse = getNum("maxImpulse", 18);
    const cooldown = getNum("cooldown", 0.30);
    const impulse = (maxImpulse * IMPULSE_MULT) * Math.max(0, Math.min(1, pullRatio));

    Body.setVelocity(coin, { x: s.dir * impulse, y: -impulse * UPWARD_BIAS_FIXED });
    Body.setAngularVelocity(coin, 0);

    s.cooldownUntil = now + cooldown;
  }

  async function respawnCoinAndBroadcast(isBack){
    // Back: "現在の10円玉が消え���新しく生成"
    // We implement as respawn + broadcast spawn audio + reset velocity.
    Body.setPosition(coin, {x:spawnPoint.x, y:spawnPoint.y});
    Body.setVelocity(coin, {x:0, y:0});
    Body.setAngularVelocity(coin, 0);
    playSound("spawn");
    await broadcastAudio(isBack ? "spawn" : "spawn");
    await pushCoinState();
    await markPlayerInput();
  }

  async function pushCoinState(){
    if (!localRole.isPlayer) return;
    const v = coin.velocity;
    await update(stateRef, {
      coin: {
        x: coin.position.x,
        y: coin.position.y,
        vx: v.x,
        vy: v.y,
        angle: coin.angle,
        angVel: coin.angularVelocity
      }
    }).catch(()=>{});
  }

  // ==========================
  // World build
  // ==========================
  async function rebuildWorld(){
    // destroy old
    if (render){
      Render.stop(render);
      render.canvas.remove();
      render.textures = {};
    }
    if (runner) Runner.stop(runner);
    if (engine){
      World.clear(engine.world, false);
      Engine.clear(engine);
    }

    engine = Engine.create();
    engine.gravity.y = getNum("gravityY", 1);

    render = Render.create({
      element: $("main"),
      engine,
      options: {
        width: mapW,
        height: mapH,
        wireframes: false,
        background: "#000",
        hasBounds: false,
        pixelRatio: window.devicePixelRatio || 1
      }
    });
    runner = Runner.create();
    Render.run(render);
    Runner.run(runner, engine);

    // background: map.png for everyone (fallback to map.png fail => ren.png)
    let bgUrl = MAP_URL;
    try{ await loadImage(MAP_URL); } catch(e){ bgUrl = REN_URL; }
    setBackground(bgUrl);

    window.addEventListener("resize", resizeCanvasToFit);
    requestAnimationFrame(resizeCanvasToFit);

    // Build masks from ren.png (already loaded)
    const masks = await loadRenAndMasks();

    // choose spawn
    const greenComps = extractComponents(masks.green, mapW, mapH);
    spawnPoint = greenComps.length ? greenComps[0].centroid : {x:100,y:100};

    // terrain
    const iters = getNum("smoothIters", 2);
    const thresh = getNum("smoothThresh", 0.58);
    const smooth = iters > 0 ? smoothBinaryMask(masks.black, mapW, mapH, iters, thresh) : masks.black;
    blackMaskGlobal = smooth;

    const boundaryPts = extractBoundaryPoints(smooth, mapW, mapH);
    const step = 6;
    const segs = pointsToSegmentsApproxSmooth(boundaryPts, step, 2);
    const terrainBodies = segs.map(s=> segmentToBody(s, 6));
    terrainBodies.forEach(b=> b.label="terrain");
    World.add(engine.world, terrainBodies);

    // holes (red)
    holes = [];
    const redComps = extractComponents(masks.red, mapW, mapH);
    for (const c of redComps){
      let r = Math.sqrt(c.area / Math.PI);
      r = Math.max(12, Math.min(90, r));
      const hole = Bodies.circle(c.centroid.x, c.centroid.y, r, { isStatic:true, isSensor:true, render:{visible:false} });
      hole.label="hole";
      holes.push(hole);
    }
    World.add(engine.world, holes);

    // goals (blue)
    goals = [];
    const blueComps = extractComponents(masks.blue, mapW, mapH);
    for (const c of blueComps){
      let r = Math.sqrt(c.area / Math.PI);
      r = Math.max(14, Math.min(110, r));
      const goal = Bodies.circle(c.centroid.x, c.centroid.y, r, { isStatic:true, isSensor:true, render:{visible:false} });
      goal.label="goal";
      goals.push(goal);
    }
    World.add(engine.world, goals);

    // springs (yellow)
    springs = [];
    const yellowComps = extractComponents(masks.yellow, mapW, mapH);
    const centerX = mapW/2;
    const picked = yellowComps.slice(0,6);
    for (const c of picked){
      const dir = (c.centroid.x < centerX) ? +1 : -1; // left->right, right->left
      const pad = 8;
      const aabb = { minX:c.aabb.minX-pad, minY:c.aabb.minY-pad, maxX:c.aabb.maxX+pad, maxY:c.aabb.maxY+pad };
      const sensor = Bodies.rectangle(
        (aabb.minX+aabb.maxX)/2,
        (aabb.minY+aabb.maxY)/2,
        Math.max(10, aabb.maxX-aabb.minX),
        Math.max(10, aabb.maxY-aabb.minY),
        { isStatic:true, isSensor:true, render:{visible:false} }
      );
      sensor.label="springSensor";
      springs.push({ sensor, center:{x:c.centroid.x,y:c.centroid.y}, dir, cooldownUntil:0, aabb });
    }
    World.add(engine.world, springs.map(s=>s.sensor));

    // coin
    await coinTexture.load().catch(()=>{});
    const r = getNum("coinR", 32);
    coin = Bodies.circle(spawnPoint.x, spawnPoint.y, r, {
      restitution: 0,
      friction: 0.012,
      frictionStatic: 0.12,
      frictionAir: 0.006,
      density: 0.005,
      render: { fillStyle: "rgba(0,0,0,0)", strokeStyle:"rgba(0,0,0,0)", lineWidth: 0 }
    });
    World.add(engine.world, coin);

    // spawn sound local
    playSound("spawn");

    // events
    installWorldEvents();
  }

  function installWorldEvents(){
    // prevent duplicate
    Events.off(engine, "collisionStart");
    Events.off(engine, "collisionActive");
    Events.off(engine, "afterUpdate");
    Events.off(render, "afterRender");

    Events.on(engine, "collisionStart", (ev)=>{
      // strong hit sound for player + spectators (broadcast)
      if (!coin) return;
      const now = performance.now();
      if (now - lastHitAt < HIT_COOLDOWN_MS) return;

      for (const pair of ev.pairs){
        const a = pair.bodyA, b = pair.bodyB;
        if (!(a===coin || b===coin)) continue;
        const other = (a===coin) ? b : a;
        if (other.label !== "terrain") continue;

        const rel = Math.hypot(coin.velocity.x - (other.velocity?.x||0), coin.velocity.y - (other.velocity?.y||0));
        if (rel >= HIT_SPEED_TH){
          lastHitAt = now;
          playSound("hit");
          if (localRole.isPlayer) broadcastAudio("hit");
          break;
        }
      }
    });

    Events.on(engine, "collisionActive", (ev)=>{
      touchingGround = false;
      lastGroundNormal = null;

      for (const pair of ev.pairs){
        const a = pair.bodyA, b = pair.bodyB;

        if ((a===coin && b.label==="hole") || (b===coin && a.label==="hole")){
          if (localRole.isPlayer){
            playSound("fail");
            broadcastAudio("fail");
            respawnCoinAndBroadcast(false);
          }
          continue;
        }

        if ((a===coin && b.label==="goal") || (b===coin && a.label==="goal")){
          if (localRole.isPlayer){
            playSound("clear");
            broadcastAudio("clear");
            // clear overlay only for player, 10 sec
            showClearOverlayFor10s();
            // set room cleared
            update(stateRef, {
              phase: "cleared",
              clear: { by: myName, at: serverTimestamp() },
            }).catch(()=>{});
            // respawn after clear
            respawnCoinAndBroadcast(false);
            // back to idle after short moment
            setTimeout(()=> update(stateRef, { phase:"idle", player:null, lastInputAt:0 }).catch(()=>{}), 1200);
          }
          continue;
        }

        const isTerrainContact =
          (a===coin && b.label==="terrain") || (b===coin && a.label==="terrain");
        if (isTerrainContact){
          touchingGround = true;
          lastGroundNormal = pair.collision.normal;
        }
      }
    });

    Events.on(engine, "afterUpdate", ()=>{
      if (!coin) return;

      // choose active spring for UI direction
      const s = nearestSpringByDistance();
      lever.activeSpring = s;
      lever.enabled = !!s;

      // apply slope assist always (player + spectator) to make the observed motion consistent locally
      applySlopeAssist();

      // push state from player periodically
      if (localRole.isPlayer){
        // throttle
        if (!pushCoinState._t || performance.now() - pushCoinState._t > 50){
          pushCoinState._t = performance.now();
          pushCoinState();
        }
      }

      // UI enable conditions
      setLeverUI(lever.enabled && localRole.isPlayer && localRole.playing, lever.pullRatio, lever.activeSpring);

      // flat stop only on near-flat
      if (touchingGround && lastGroundNormal){
        const n = lastGroundNormal;
        const slopeMeasure = Math.abs(n.x);
        if (Math.abs(coin.velocity.x) < 0.03 && Math.abs(coin.angularVelocity) < 0.012 && slopeMeasure < 0.05){
          Body.setVelocity(coin, { x: 0, y: coin.velocity.y });
          Body.setAngularVelocity(coin, 0);
        }
      }
    });

    Events.on(render, "afterRender", ()=>{
      const ctx = render.context;

      // draw only what required:
      // everyone: map background already. draw yellow frames + coin image.
      drawYellowFrames(ctx);
      coinRender(ctx);

      if (overlay.showAdmin()){
        drawAdminOverlays(ctx);
      }
    });
  }

  // clear overlay only for player
  function showClearOverlayFor10s(){
    const ov = $("clearOverlay");
    ov.style.display = "flex";
    setTimeout(()=>{ ov.style.display = "none"; }, 10_000);
  }

  // ==========================
  // Firebase listeners (state sync)
  // ==========================
  function renderRoomStatus(st, waiting){
    const phase = st?.phase || "idle";
    const player = st?.player?.name || "-";
    const isPlaying = (st?.player?.id === clientId) && phase === "playing";

    // buttons
    $("btnPlay").disabled = !(phase === "idle");
    $("btnEnd").disabled = !isPlaying;
    $("btnBack").disabled = !isPlaying;
    $("btnReset").disabled = !isPlaying;

    // wait button visible when not playing
    $("btnWait").disabled = isPlaying;

    // show status
    const lines = [];
    lines.push(`phase: ${phase}`);
    lines.push(`player: ${player}`);
    lines.push(`you: ${myName} (${clientId.slice(0,6)})`);
    lines.push(`role: ${isPlaying ? "PLAYER" : "SPECTATOR"}`);
    if (st?.clear?.by) lines.push(`lastClear: ${st.clear.by}`);
    $("roomStatus").textContent = lines.join("\n");

    // wait list
    const waitLines = [];
    if (waiting){
      const entries = Object.entries(waiting);
      if (entries.length === 0){
        $("waitList").textContent = "(none)";
      } else {
        for (const [id, v] of entries){
          waitLines.push(`${v?.name || "匿名"} (${String(id).slice(0,6)})`);
        }
        $("waitList").textContent = waitLines.join("\n");
      }
    } else {
      $("waitList").textContent = "(none)";
    }

    // local role
    localRole.isPlayer = isPlaying;
    localRole.playing = isPlaying;
    localRole.playerId = st?.player?.id || "";
    localRole.playerName = st?.player?.name || "";

    // spectator: enforce idle timeout (helps unlock if player disappears)
    if (!isPlaying){
      enforceIdleTimeoutIfNeeded(st);
      refreshWaitingListIfNeeded();
    }

    // spectator: apply remote coin state (watch)
    if (!isPlaying && st?.coin && coin){
      Body.setPosition(coin, { x: st.coin.x, y: st.coin.y });
      Body.setVelocity(coin, { x: st.coin.vx, y: st.coin.vy });
      Body.setAngle(coin, st.coin.angle || 0);
      Body.setAngularVelocity(coin, st.coin.angVel || 0);
    }

    // audio events for spectators
    if (!isPlaying && st?.audio?.type){
      // play corresponding sound locally
      if (["fail","shot","hit","spawn","clear"].includes(st.audio.type)){
        playSound(st.audio.type);
        if (st.audio.type === "clear"){
          // spectators do not show image per requirement
        }
      }
    }
  }

  // ==========================
  // Startup guard (avoid duplicate init)
  // ==========================
  let loadedOnce = false;
  async function ensureLoadedOnce(){
    if (loadedOnce) return;
    loadedOnce = true;

    await ensureRoomInitializedOnce();
    await coinTexture.load().catch(()=>{});

    // build world and start rendering locally
    await rebuildWorld();

    // wire firebase listeners (single)
    let latestState = null;
    let latestWait = null;

    onValue(stateRef, (snap)=>{
      latestState = snap.val();
      renderRoomStatus(latestState, latestWait);
    });

    onValue(waitRef, (snap)=>{
      latestWait = snap.val();
      renderRoomStatus(latestState, latestWait);
    });
  }

  // ==========================
  // Start at selection screen
  // ==========================
  showScreen("select");
</script>
</body>
</html>
