<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ゲーム</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --ui-w: 360px;
      --bg:#111;
      --panel:#0b0b0b;
      --border:#333;
      --text:#eee;
      --muted:#bbb;
      --accent:#ffd24a;
    }
    html,body{ margin:0; height:100%; background:var(--bg); color:var(--text); font-family:system-ui,sans-serif; overflow:hidden; }
    button,input{ font-family:inherit; }
    .screen{ display:none; height:100vh; }
    .screen.active{ display:block; }

    /* menu */
    #menu{
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #menu .card{
      width:min(560px, 92vw);
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:14px;
      padding:18px;
    }
    #menu h1{ margin:0 0 10px; font-size:16px; }
    #menu .row{ margin:10px 0; display:flex; gap:10px; flex-wrap:wrap; }
    #menu button{
      background:#333; color:#eee; border:1px solid #555; border-radius:8px;
      padding:10px 12px; cursor:pointer;
    }
    #menu button:hover{ background:#444; }

    /* name screen */
    #nameScreen{
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #nameScreen .card{
      width:min(560px, 92vw);
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:14px;
      padding:18px;
    }
    #nameScreen h1{ margin:0 0 10px; font-size:16px; }
    #nameScreen .row{ margin:10px 0; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    #nameScreen input{
      width: 220px;
      background:#222; color:#eee; border:1px solid #555; border-radius:8px; padding:10px 12px;
    }
    #nameScreen button{
      background:#333; color:#eee; border:1px solid #555; border-radius:8px;
      padding:10px 12px; cursor:pointer;
    }

    /* game layout */
    #game{
      display:grid;
      grid-template-columns: var(--ui-w) 1fr;
      height:100vh;
      width:100vw;
    }
    #ui{
      padding: 12px;
      box-sizing:border-box;
      border-right: 1px solid var(--border);
      background:var(--panel);
      overflow:auto;
    }
    #ui h1{ font-size:14px; margin:0 0 10px; }
    .label{ font-size:11px; color:var(--muted); margin-bottom:6px; }
    .row{ margin:10px 0; }
    .btn{
      background:#333; color:#eee; border:1px solid #555; border-radius:8px;
      padding:8px 10px; cursor:pointer; font-size:12px;
    }
    .btn:hover{ background:#444; }
    .btn.primary{ border-color: rgba(255,210,74,0.6); }
    .btn.danger{ border-color: rgba(255,80,80,0.6); }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .chip{
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.06);
      font-size:11px;
      color:rgba(255,255,255,0.8);
      white-space:nowrap;
    }

    /* lever */
    #leverBox{
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 10px;
    }
    #leverTitle{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      margin-bottom:8px; font-size:12px; color:var(--accent);
    }
    #leverBadge{
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.25);
      color: rgba(255,255,255,0.85);
      white-space: nowrap;
    }
    #leverBadge.off{ color: rgba(255,255,255,0.45); }
    #pullArea{
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      position: relative;
      overflow:hidden;
      user-select:none;
      touch-action:none;
      cursor: grab;
    }
    #pullArea:active{ cursor: grabbing; }
    #pullFill{
      position:absolute; left:0; top:0; bottom:0;
      width:0%;
      background: linear-gradient(90deg, #20ff70, #ffee55, #ff8a22, #ff2a2a);
      opacity: 0.9;
    }
    #pullKnob{
      position:absolute;
      top:50%;
      transform: translate(-50%,-50%);
      width:18px; height:18px; border-radius:999px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 2px 10px rgba(0,0,0,0.45);
      left:0%;
    }
    #leverNums{ margin-top:8px; display:flex; justify-content:space-between; gap:8px; }

    /* world */
    #world{
      position:relative;
      overflow:hidden;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #world canvas{
      display:block;
      max-width:100%;
      max-height:100%;
      width:auto; height:auto;
      background:#000;
    }

    /* clear overlay */
    #clearOverlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.35);
      z-index: 10;
    }
    #clearOverlay img{
      width:min(520px, 90vw);
      height:auto;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.18);
      box-shadow: 0 10px 40px rgba(0,0,0,0.55);
      background:#000;
    }

    /* admin gate */
    body:not(.admin) .adminOnly{ display:none; }
    body.admin .adminOnly{ display:block; }

    /* spectator/player */
    .spectatorOnly{ display:none; }
    body.spectator .spectatorOnly{ display:block; }
    body.player .spectatorOnly{ display:none; }

    .playerOnly{ display:none; }
    body.player .playerOnly{ display:block; }
    body.spectator .playerOnly{ display:none; }

    #status{
      white-space:pre;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      color:#cfc;
    }
  </style>
</head>
<body>

<section id="menu" class="screen active">
  <div class="card">
    <h1>ゲ���ム選択</h1>
    <div class="row">
      <button id="btnJanken">じゃんけんゲーム（未実装）</button>
      <button id="btnTenyen">10円ゲーム</button>
    </div>
    <div style="color:#888;font-size:12px;line-height:1.5;">
      ※10円ゲームは「同時に1人だけプレイ」できます。ほかは観戦になります。
    </div>
  </div>
</section>

<section id="nameScreen" class="screen">
  <div class="card">
    <h1>名前入力</h1>
    <div class="row">
      <input id="nameInput" placeholder="名前（空なら匿名）">
      <button id="btnNameOk">決定</button>
      <button id="btnNameBack">戻る</button>
    </div>
    <div style="color:#888;font-size:12px;">決定を押すと10円ゲームに入ります。</div>
  </div>
</section>

<section id="game" class="screen">
  <aside id="ui">
    <h1>10円ゲーム</h1>

    <div class="row">
      <div class="chip" id="youChip">you: -</div>
      <div class="chip" id="roleChip">role: -</div>
      <div class="chip" id="playerChip">playing: -</div>
    </div>

    <div class="row">
      <button class="btn primary" id="btnPlay">プレイ開始</button>
      <button class="btn danger playerOnly" id="btnEnd">終わる</button>
    </div>

    <div class="row playerOnly">
      <button class="btn" id="btnBackReset">戻る（新しく生成）</button>
      <button class="btn" id="btnCoinReset">10円リセット</button>
    </div>

    <div class="row spectatorOnly">
      <button class="btn" id="btnWait">待機</button>
      <div style="margin-top:6px;color:#aaa;font-size:12px;" id="waitMsg"></div>
      <div style="margin-top:10px;color:#bbb;font-size:12px;">待機中:</div>
      <div id="waitList" style="font-size:12px;color:#ddd;line-height:1.5;"></div>
    </div>

    <div class="row" id="leverBox">
      <div id="leverTitle">
        <div>バー（引いて→離す）</div>
        <div id="leverBadge" class="off">OFF</div>
      </div>

      <div id="pullArea">
        <div id="pullFill"></div>
        <div id="pullKnob"></div>
      </div>

      <div id="leverNums">
        <div class="chip" id="powChip">0%</div>
        <div class="chip" id="dirChip">dir:-</div>
      </div>

      <div style="margin-top:8px;font-size:11px;color:rgba(255,255,255,0.75);line-height:1.35;">
        ※プレイヤーのときだけ発射できます（観戦者は動かせません）
      </div>
    </div>

    <div class="row">
      <div class="label">運営モード（1122）</div>
      <input id="adminPass" type="password" placeholder="1122">
      <button class="btn" id="adminEnter">決定</button>
      <button class="btn" id="adminExit" style="display:none;">退出</button>
      <div id="adminMsg" style="margin-top:6px;font-size:11px;color:#aaa;"></div>
    </div>

    <div class="row adminOnly">
      <div class="label">運営：調整</div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;">
        <div>
          <div class="label">重力</div>
          <input id="gravityY" type="number" value="1" step="0.1" min="0" max="5">
        </div>
        <div>
          <div class="label">maxImpulse(×1.5)</div>
          <input id="maxImpulse" type="number" value="18" step="1" min="1" max="200">
        </div>
        <div>
          <div class="label">maxPull</div>
          <input id="maxPull" type="number" value="150" step="10" min="40" max="500">
        </div>
        <div>
          <div class="label">nearDist</div>
          <input id="nearDist" type="number" value="180" step="10" min="20" max="800">
        </div>
        <div>
          <div class="label">cooldown</div>
          <input id="cooldown" type="number" value="0.30" step="0.05" min="0" max="2">
        </div>
        <div>
          <div class="label">slopeProbe</div>
          <input id="slopeProbe" type="number" value="34" step="2" min="6" max="200">
        </div>
        <div>
          <div class="label">slopeAssist</div>
          <input id="slopeAssist" type="number" value="2.0" step="0.1" min="0" max="20">
        </div>
        <div>
          <div class="label">smoothIters</div>
          <input id="smoothIters" type="number" value="2" step="1" min="0" max="8">
        </div>
        <div>
          <div class="label">smoothThresh</div>
          <input id="smoothThresh" type="number" value="0.58" step="0.01" min="0.5" max="0.9">
        </div>
        <div>
          <div class="label">segStep</div>
          <input id="segStep" type="number" value="6" step="1" min="2" max="24">
        </div>
      </div>
    </div>

    <div class="row adminOnly">
      <div class="label">状態</div>
      <div id="status">loading...</div>
    </div>

  </aside>

  <main id="world">
    <div id="clearOverlay"><img src="krg.png" alt="clear"></div>
  </main>
</section>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>

<script type="module">
  // ==========================
  // Firebase 初期化
  // ==========================
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-analytics.js";
  import {
    getDatabase,
    ref,
    onValue,
    set,
    update,
    push,
    serverTimestamp,
    onDisconnect,
    get
  } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCC7KAv7V4j1Z6-o1Y8ikmb3r5htN9O_aA",
    authDomain: "zzgohan-280.firebaseapp.com",
    databaseURL: "https://zzgohan-280-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "zzgohan-280",
    storageBucket: "zzgohan-280.firebasestorage.app",
    messagingSenderId: "459336048542",
    appId: "1:459336048542:web:ff6c825dec81cc7df8008f",
    measurementId: "G-JX4RP9LWR3"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const db = getDatabase(app);

  // --------------------------
  // Utility
  // --------------------------
  const $ = (id)=>document.getElementById(id);
  const isAdminMode = () => document.body.classList.contains("admin"); // ★1回だけ

  function showScreen(id){
    for (const el of document.querySelectorAll(".screen")) el.classList.remove("active");
    $(id).classList.add("active");
  }

  // Menu -> Name -> Game
  $("btnTenyen").addEventListener("click", ()=>showScreen("nameScreen"));
  $("btnJanken").addEventListener("click", ()=>alert("じゃんけんゲームは未実装です"));
  $("btnNameBack").addEventListener("click", ()=>showScreen("menu"));
  $("btnNameOk").addEventListener("click", ()=>{
    const name = ($("nameInput").value || "").trim() || "匿名";
    sessionStorage.setItem("tenyen_name", name);
    showScreen("game");
    initGameOnce();
  });

  // --------------------------
  // Audio (unlock)
  // --------------------------
  const sounds = {
    fail: new Audio("s.mp3"),
    shot: new Audio("u.mp3"),
    hit:  new Audio("b.mp3"),
    spawn:new Audio("t.mp3"),
    clear:new Audio("kr.mp3"),
  };
  for (const a of Object.values(sounds)){ a.preload="auto"; a.volume=0.9; }

  let audioUnlocked = false;
  async function unlockAudioOnce(){
    if (audioUnlocked) return;
    audioUnlocked = true;
    try{
      const a = sounds.spawn;
      const prev = a.volume;
      a.volume = 0;
      a.currentTime = 0;
      await a.play();
      a.pause();
      a.currentTime = 0;
      a.volume = prev;
    }catch(e){
      console.warn("audio unlock failed:", e);
    }
  }
  function playSound(key){
    const a = sounds[key];
    if (!a) return;
    try{
      a.pause();
      a.currentTime = 0;
      a.play().catch(()=>{});
    }catch(e){}
  }

  // --------------------------
  // Firebase paths / helpers
  // --------------------------
  const PATH = {
    state: ref(db, "tenyen/state"),
    coin: ref(db, "tenyen/coin"),
    events: ref(db, "tenyen/events"),
    waiting: ref(db, "tenyen/waiting"),
    ann: ref(db, "tenyen/announcements"),
  };

  function emitEvent(type, payload={}){
    push(PATH.events, { type, payload, at: serverTimestamp() });
  }

  // --------------------------
  // Admin mode
  // --------------------------
  const ADMIN_PASSWORD = "1122";
  function setAdminMode(on){
    document.body.classList.toggle("admin", !!on);
    $("adminExit").style.display = on ? "inline-block" : "none";
  }
  setAdminMode(false);

  $("adminEnter").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if ($("adminPass").value === ADMIN_PASSWORD){
      setAdminMode(true);
      $("adminMsg").textContent = "運営モードON";
      $("adminPass").value = "";
    } else {
      $("adminMsg").textContent = "パスワードが違います";
    }
  });
  $("adminExit").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    setAdminMode(false);
    $("adminMsg").textContent = "運営モードOFF";
  });

  // --------------------------
  // Multiplayer state
  // --------------------------
  const PLAY_IDLE_TIMEOUT_MS = 60_000;

  let yourName = sessionStorage.getItem("tenyen_name") || "匿名";
  $("youChip").textContent = `you: ${yourName}`;

  let role = "spectator";
  function setRole(newRole){
    role = newRole;
    document.body.classList.toggle("player", role==="player");
    document.body.classList.toggle("spectator", role!=="player");
    $("roleChip").textContent = `role: ${role}`;
  }
  setRole("spectator");

  async function claimPlay(){
    await unlockAudioOnce();
    const snap = await get(PATH.state);
    const st = snap.exists() ? snap.val() : null;

    if (st && st.playing) return false;

    await set(PATH.state, {
      playing: true,
      playerName: yourName,
      startedAt: serverTimestamp(),
      lastActionAt: Date.now() // ★数値で保存（無操作切りのため）
    });

    try{
      await onDisconnect(PATH.state).update({
        playing:false, playerName:"", lastActionAt: Date.now(), reason:"disconnect"
      });
    }catch(e){}

    setRole("player");
    emitEvent("sound", { key:"spawn" });
    return true;
  }

  async function releasePlay(reason="end"){
    await update(PATH.state, { playing:false, playerName:"", lastActionAt: Date.now(), reason });
    setRole("spectator");
  }

  function touchAction(){
    if (role !== "player") return;
    update(PATH.state, { lastActionAt: Date.now() }).catch(()=>{});
  }

  // Waiting
  function renderWaitingList(list){
    const names = (list ? Object.values(list).map(v=>v?.name).filter(Boolean) : []);
    $("waitList").textContent = names.length ? names.join(" / ") : "(なし)";
  }
  onValue(PATH.waiting, (snap)=>renderWaitingList(snap.exists()?snap.val():null));
  onValue(PATH.ann, (snap)=>{
    if (!snap.exists()) return;
    const a = snap.val();
    if (!a || !a.message) return;
    if (role !== "player"){
      $("waitMsg").textContent = a.message;
      setTimeout(()=>{ $("waitMsg").textContent=""; }, 5000);
    }
  });

  $("btnWait").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if (role === "player") return;
    const key = yourName + "_" + Math.random().toString(16).slice(2,8);
    await set(ref(db, `tenyen/waiting/${key}`), { name: yourName, at: Date.now() });
    $("waitMsg").textContent = "待機しました";
  });

  // 10分リセット（簡易）
  let lastWaitingResetAt = 0;
  setInterval(async ()=>{
    if (role === "player") return;
    const now = Date.now();
    if (now - lastWaitingResetAt < 10*60*1000) return;
    lastWaitingResetAt = now;
    try{
      await set(PATH.waiting, null);
      await set(PATH.ann, { message: "待機列をリセットしました（10分ごと）", at: Date.now() });
    }catch(e){}
  }, 30_000);

  // UI buttons
  $("btnPlay").addEventListener("click", async ()=>{
    const ok = await claimPlay();
    if (!ok) alert("いま誰かがプレイ中です。観戦してください。");
  });
  $("btnEnd").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if (role !== "player") return;
    await releasePlay("end");
  });

  // --------------------------
  // Game resources
  // --------------------------
  const REN_URL = "ren.png";
  const MAP_URL = "map.png";
  const COIN_IMG_URL = "10.png";
  const CLEAR_IMG_URL = "krg.png";
  $("clearOverlay").querySelector("img").src = CLEAR_IMG_URL;

  // --------------------------
  // Physics tuning
  // --------------------------
  const UPWARD_BIAS_FIXED = 0;
  const IMPULSE_MULT = 1.5;

  const SLOPE_ACCEL_MULT = 2.0;
  const SLOPE_EXTRA_MULT = 2.8;
  const STUCK_BOOST_MULT = 3.8;
  const STUCK_SPEED_TH = 0.22;
  const MIN_SIN_TO_APPLY = 0.015;

  const HIT_SPEED_TH = 7.0;
  const HIT_COOLDOWN_MS = 120;
  let lastHitAt = 0;

  // --------------------------
  // Color classify & extraction
  // --------------------------
  function classifyPixel(r,g,b,a){
    if (a < 10) return "empty";
    if (r < 40 && g < 40 && b < 40) return "black";
    if (r > 180 && g < 80 && b < 80) return "red";
    if (g > 160 && r < 120 && b < 120) return "green";
    if (r > 180 && g > 180 && b < 120) return "yellow";
    if (b > 180 && r < 100 && g < 140) return "blue";
    return "empty";
  }

  function extractComponents(mask, w, h){
    const visited = new Uint8Array(w*h);
    const comps = [];
    const qx = new Int32Array(w*h);
    const qy = new Int32Array(w*h);
    const idx = (x,y)=>y*w+x;
    const pushQ = (x,y,tail)=>{ qx[tail]=x; qy[tail]=y; return tail+1; };

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = idx(x,y);
        if (!mask[i] || visited[i]) continue;

        let head=0, tail=0;
        tail = pushQ(x,y,tail);
        visited[i]=1;

        let sumX=0, sumY=0, area=0;
        let minX=x, minY=y, maxX=x, maxY=y;

        while(head<tail){
          const cx=qx[head], cy=qy[head]; head++;
          area++;
          sumX += cx; sumY += cy;
          if (cx<minX) minX=cx; if (cy<minY) minY=cy;
          if (cx>maxX) maxX=cx; if (cy>maxY) maxY=cy;

          const n1 = (cx>0)   ? idx(cx-1,cy) : -1;
          const n2 = (cx<w-1) ? idx(cx+1,cy) : -1;
          const n3 = (cy>0)   ? idx(cx,cy-1) : -1;
          const n4 = (cy<h-1) ? idx(cx,cy+1) : -1;

          if (n1>=0 && mask[n1] && !visited[n1]){ visited[n1]=1; tail=pushQ(cx-1,cy,tail); }
          if (n2>=0 && mask[n2] && !visited[n2]){ visited[n2]=1; tail=pushQ(cx+1,cy,tail); }
          if (n3>=0 && mask[n3] && !visited[n3]){ visited[n3]=1; tail=pushQ(cx,cy-1,tail); }
          if (n4>=0 && mask[n4] && !visited[n4]){ visited[n4]=1; tail=pushQ(cx,cy+1,tail); }
        }

        comps.push({
          area,
          centroid: { x: sumX / area, y: sumY / area },
          aabb: { minX, minY, maxX, maxY }
        });
      }
    }
    comps.sort((a,b)=>b.area-a.area);
    return comps;
  }

  function smoothBinaryMask(mask, w, h, iters=2, threshold=0.58){
    let src = mask;
    let dst = new Uint8Array(w*h);
    const idx = (x,y)=>y*w+x;

    for (let iter=0; iter<iters; iter++){
      dst.fill(0);
      for (let y=1; y<h-1; y++){
        for (let x=1; x<w-1; x++){
          let count = 0;
          count += src[idx(x-1,y-1)];
          count += src[idx(x  ,y-1)];
          count += src[idx(x+1,y-1)];
          count += src[idx(x-1,y  )];
          count += src[idx(x  ,y  )];
          count += src[idx(x+1,y  )];
          count += src[idx(x-1,y+1)];
          count += src[idx(x  ,y+1)];
          count += src[idx(x+1,y+1)];
          dst[idx(x,y)] = (count/9 >= threshold) ? 1 : 0;
        }
      }
      for (let x=0;x<w;x++){ dst[idx(x,0)] = src[idx(x,0)]; dst[idx(x,h-1)] = src[idx(x,h-1)]; }
      for (let y=0;y<h;y++){ dst[idx(0,y)] = src[idx(0,y)]; dst[idx(w-1,y)] = src[idx(w-1,y)]; }
      const tmp = src; src = dst; dst = tmp;
    }
    return src;
  }

  function extractBoundaryPoints(blackMask, w, h){
    const pts = [];
    const idx = (x,y)=>y*w+x;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const i = idx(x,y);
        if (!blackMask[i]) continue;
        if (!blackMask[idx(x-1,y)] || !blackMask[idx(x+1,y)] || !blackMask[idx(x,y-1)] || !blackMask[idx(x,y+1)]) {
          pts.push({x,y});
        }
      }
    }
    return pts;
  }

  function pointsToSegmentsApproxSmooth(points, sampleStep=6, grid=2){
    const segs = [];
    const snap = (v)=>Math.round(v / grid) * grid;

    const pts = [];
    for (let i=0; i<points.length; i+=sampleStep){
      const p = points[i];
      pts.push({ x: snap(p.x), y: snap(p.y) });
    }

    const maxD2 = (sampleStep*sampleStep*20);
    const minD2 = 4;

    for (let i=0; i<pts.length; i++){
      const p = pts[i];
      let bestJ = -1;
      let bestD2 = Infinity;

      for (let j=i+1; j<Math.min(pts.length, i+220); j++){
        const q = pts[j];
        const dx=q.x-p.x, dy=q.y-p.y;
        const d2=dx*dx+dy*dy;
        if (d2 < minD2) continue;
        if (d2 < bestD2 && d2 < maxD2){
          bestD2 = d2;
          bestJ = j;
        }
      }

      if (bestJ >= 0){
        const q = pts[bestJ];
        segs.push({x1:p.x,y1:p.y,x2:q.x,y2:q.y});
      }
    }
    return segs;
  }

  // --------------------------
  // Matter setup
  // --------------------------
  const Matter = window.Matter;
  const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

  let inited = false;

  let engine, render, runner;
  let renCanvas, renCtx, renData;
  let mapW=0, mapH=0;

  let coinBody = null;
  let spawnPoint = {x:100,y:100};

  let holes=[];
  let goals=[];
  let springs=[];
  let touchingGround=false;
  let lastGroundNormal=null;
  let blackMaskGlobal=null;

  // coin image
  const coinImg = new Image();
  coinImg.src = COIN_IMG_URL;

  // lever state
  let lever = {
    enabled:false,
    activeSpring:null,
    dragging:false,
    pointerId:null,
    startX:0,
    currentX:0,
    pullRatio:0
  };

  // --------------------------
  // build images/masks
  // --------------------------
  async function loadImage(url){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=>resolve(img);
      img.onerror = reject;
      img.src = url + "?t=" + Date.now();
    });
  }

  function buildRenImageData(img){
    mapW = img.naturalWidth || img.width;
    mapH = img.naturalHeight || img.height;

    renCanvas = document.createElement("canvas");
    renCanvas.width = mapW;
    renCanvas.height = mapH;
    renCtx = renCanvas.getContext("2d", { willReadFrequently:true });
    renCtx.drawImage(img, 0, 0);
    renData = renCtx.getImageData(0,0,mapW,mapH);
  }

  function buildMasks(){
    const w=mapW, h=mapH;
    const data=renData.data;
    const black = new Uint8Array(w*h);
    const red   = new Uint8Array(w*h);
    const green = new Uint8Array(w*h);
    const yellow= new Uint8Array(w*h);
    const blue  = new Uint8Array(w*h);

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        const c = classifyPixel(r,g,b,a);
        const p=y*w+x;
        if (c==="black") black[p]=1;
        else if (c==="red") red[p]=1;
        else if (c==="green") green[p]=1;
        else if (c==="yellow") yellow[p]=1;
        else if (c==="blue") blue[p]=1;
      }
    }
    return {black, red, green, yellow, blue};
  }

  function createEngineAndRenderer(){
    engine = Engine.create();
    engine.gravity.y = getNum("gravityY", 1);

    render = Render.create({
      element: $("world"),
      engine,
      options: {
        width: mapW,
        height: mapH,
        wireframes: false,
        background: "#000",
        hasBounds: false,
        pixelRatio: window.devicePixelRatio || 1
      }
    });

    runner = Runner.create();
    Render.run(render);
    Runner.run(runner, engine);

    requestAnimationFrame(resizeCanvasToFit);
    window.addEventListener("resize", resizeCanvasToFit);
  }

  async function setBackground(url){
    render.options.background = `url(${url})`;
    render.canvas.style.backgroundImage = `url(${url})`;
    render.canvas.style.backgroundSize = "100% 100%";
    render.canvas.style.backgroundRepeat = "no-repeat";
    render.canvas.style.backgroundPosition = "0 0";
    await loadImage(url); // preload check
  }

  function resizeCanvasToFit(){
    if (!render) return;
    const canvas = render.canvas;
    const rect = $("world").getBoundingClientRect();
    const scale = Math.min(rect.width / mapW, rect.height / mapH);
    canvas.style.width = (mapW * scale) + "px";
    canvas.style.height = (mapH * scale) + "px";
  }

  function getNum(id, fallback){
    const el = $(id);
    if (!el) return fallback;
    const v = parseFloat(el.value);
    return Number.isFinite(v) ? v : fallback;
  }

  // --------------------------
  // world building
  // --------------------------
  function segmentToBody(seg){
    const {x1,y1,x2,y2} = seg;
    const mx=(x1+x2)/2, my=(y1+y2)/2;
    const dx=x2-x1, dy=y2-y1;
    const len=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx);
    return Bodies.rectangle(mx, my, len, 6, {
      isStatic:true,
      friction: 0.55,
      restitution: 0,
      angle: ang,
      render: { visible: false }
    });
  }

  function addTerrainFromBlack(blackMask){
    const iters = Math.max(0, Math.min(8, Math.round(getNum("smoothIters", 2))));
    const thresh = Math.max(0.5, Math.min(0.9, getNum("smoothThresh", 0.58)));
    const smooth = (iters > 0) ? smoothBinaryMask(blackMask, mapW, mapH, iters, thresh) : blackMask;
    blackMaskGlobal = smooth;

    const boundaryPts = extractBoundaryPoints(smooth, mapW, mapH);
    const step = Math.max(2, Math.min(24, Math.round(getNum("segStep", 6))));
    const segs = pointsToSegmentsApproxSmooth(boundaryPts, step, 2);

    const bodies = segs.map(segmentToBody);
    for (const b of bodies) b.label="terrain";
    World.add(engine.world, bodies);
  }

  function addSensorsFromComponents(redComps, blueComps, yellowComps){
    holes = [];
    goals = [];
    springs = [];

    for (const c of redComps){
      let r = Math.sqrt(c.area / Math.PI);
      r = Math.max(12, Math.min(90, r));
      const hole = Bodies.circle(c.centroid.x, c.centroid.y, r, { isStatic:true, isSensor:true, render:{visible:false} });
      hole.label = "hole";
      holes.push(hole);
    }

    for (const c of blueComps){
      let r = Math.sqrt(c.area / Math.PI);
      r = Math.max(14, Math.min(110, r));
      const goal = Bodies.circle(c.centroid.x, c.centroid.y, r, { isStatic:true, isSensor:true, render:{visible:false} });
      goal.label = "goal";
      goals.push(goal);
    }

    const centerX = mapW/2;
    for (const c of yellowComps.slice(0,6)){
      const dir = (c.centroid.x < centerX) ? +1 : -1;
      const pad = 8;
      springs.push({
        aabb: {
          minX: c.aabb.minX - pad,
          minY: c.aabb.minY - pad,
          maxX: c.aabb.maxX + pad,
          maxY: c.aabb.maxY + pad,
        },
        center: {x:c.centroid.x, y:c.centroid.y},
        dir,
        cooldownUntil: 0
      });
    }

    World.add(engine.world, [...holes, ...goals]);
  }

  function addCoin(){
    const r = 32;
    coinBody = Bodies.circle(spawnPoint.x, spawnPoint.y, r, {
      restitution: 0,
      friction: 0.015,
      frictionStatic: 0.20,
      frictionAir: 0.008,
      density: 0.005,
      render: { visible: false }
    });
    World.add(engine.world, coinBody);
    playSound("spawn");
    emitEvent("sound", {key:"spawn"});
    touchAction();
  }

  function respawnCoin(){
    if (!coinBody) return;
    Body.setPosition(coinBody, {x:spawnPoint.x, y:spawnPoint.y});
    Body.setVelocity(coinBody, {x:0, y:0});
    Body.setAngularVelocity(coinBody, 0);
    playSound("spawn");
    emitEvent("sound", {key:"spawn"});
    shareCoin(true);
    touchAction();
  }

  function recreateCoin(){
    if (!coinBody) return;
    World.remove(engine.world, coinBody);
    coinBody = null;
    addCoin();
    shareCoin(true);
    touchAction();
  }

  // coin draw (circle crop of 10.png)
  function drawCoinImage(){
    if (!render || !coinBody) return;
    const ctx = render.context;
    const r = coinBody.circleRadius || 32;
    const x = coinBody.position.x;
    const y = coinBody.position.y;

    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.clip();

    const d = r*2;
    if (coinImg.complete && coinImg.naturalWidth > 0){
      ctx.drawImage(coinImg, x-r, y-r, d, d);
    } else {
      ctx.fillStyle = "#b87333";
      ctx.fillRect(x-r, y-r, d, d);
    }
    ctx.restore();

    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  // yellow frames always visible
  function drawYellowFrames(){
    if (!render) return;
    const ctx = render.context;
    for (const s of springs){
      const active = (s === lever.activeSpring);
      ctx.save();
      ctx.strokeStyle = active ? "rgba(255,220,80,0.95)" : "rgba(255,255,0,0.55)";
      ctx.lineWidth = active ? 4 : 3;
      const a = s.aabb;
      ctx.strokeRect(a.minX, a.minY, a.maxX-a.minX, a.maxY-a.minY);
      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = active ? "rgba(255,220,80,0.95)" : "rgba(255,255,0,0.7)";
      ctx.fillText(s.dir > 0 ? "→" : "←", s.center.x, s.center.y - 22);
      ctx.restore();
    }
  }

  // admin overlays
  function drawAdminOverlays(){
    if (!render) return;
    const ctx = render.context;
    ctx.save();
    for (const h of holes){
      ctx.beginPath();
      ctx.arc(h.position.x, h.position.y, h.circleRadius, 0, Math.PI*2);
      ctx.fillStyle="rgba(255,0,0,0.18)";
      ctx.fill();
      ctx.strokeStyle="rgba(255,0,0,0.6)";
      ctx.lineWidth=2;
      ctx.stroke();
    }
    for (const g of goals){
      ctx.beginPath();
      ctx.arc(g.position.x, g.position.y, g.circleRadius, 0, Math.PI*2);
      ctx.fillStyle="rgba(0,160,255,0.18)";
      ctx.fill();
      ctx.strokeStyle="rgba(0,160,255,0.7)";
      ctx.lineWidth=2;
      ctx.stroke();
    }
    ctx.restore();
  }

  // --------------------------
  // slope assist (strong)
  // --------------------------
  function isBlackAt(x,y){
    if (!blackMaskGlobal) return false;
    x = Math.max(0, Math.min(mapW-1, x|0));
    y = Math.max(0, Math.min(mapH-1, y|0));
    return blackMaskGlobal[y*mapW + x] === 1;
  }
  function findGroundY(x, startY, maxDown=140){
    const sx = x|0;
    let y = Math.max(0, Math.min(mapH-1, startY|0));
    for (let i=0;i<maxDown;i++){
      const yy = y + i;
      if (yy >= mapH) break;
      if (isBlackAt(sx, yy) && !isBlackAt(sx, yy-1)) return yy;
    }
    return null;
  }
  function estimateSlopeAtCoin(){
    if (!coinBody) return null;
    const probe = Math.max(6, getNum("slopeProbe", 34));
    const px = coinBody.position.x;
    const py = coinBody.position.y;

    const r = coinBody.circleRadius || 32;
    const startY = py + r * 0.6;

    const xL = Math.max(0, Math.min(mapW-1, (px - probe)|0));
    const xR = Math.max(0, Math.min(mapW-1, (px + probe)|0));
    const yL = findGroundY(xL, startY);
    const yR = findGroundY(xR, startY);
    if (yL == null || yR == null) return null;

    const dx = xR - xL;
    if (dx <= 0) return null;
    const dy = yR - yL;
    return { slope: dy / dx };
  }

  function applySlopeAssist(){
    if (!coinBody) return;
    if (!touchingGround) return;

    const est = estimateSlopeAtCoin();
    if (!est) return;

    const tan = est.slope;
    const sin = tan / Math.sqrt(1 + tan*tan);
    if (Math.abs(sin) < MIN_SIN_TO_APPLY) return;

    const g = engine.gravity.y;
    const ui = getNum("slopeAssist", 2.0);

    let k = ui * SLOPE_ACCEL_MULT * SLOPE_EXTRA_MULT;
    const speed = Math.hypot(coinBody.velocity.x, coinBody.velocity.y);
    if (speed < STUCK_SPEED_TH) k *= STUCK_BOOST_MULT;

    const ax = g * sin * k;
    const dt = 0.016;

    const v = coinBody.velocity;
    let vx = v.x + ax * dt;

    const downhillDir = (sin > 0) ? +1 : -1;
    const minRoll = (speed < STUCK_SPEED_TH) ? 0.28 : 0.14;
    if (Math.sign(vx) === downhillDir && Math.abs(vx) < minRoll){
      vx = downhillDir * minRoll;
    }

    Body.setVelocity(coinBody, { x: vx, y: v.y });
  }

  // --------------------------
  // Lever
  // --------------------------
  function coinInsideSpring(s){
    const p = coinBody.position;
    const a = s.aabb;
    return (p.x>=a.minX && p.x<=a.maxX && p.y>=a.minY && p.y<=a.maxY);
  }

  function nearestSpringByDistance(){
    const nearDist = Math.max(0, getNum("nearDist", 180));
    let best=null, bestD2=Infinity;
    for (const s of springs){
      const dx = coinBody.position.x - s.center.x;
      const dy = coinBody.position.y - s.center.y;
      const d2 = dx*dx + dy*dy;
      const near = coinInsideSpring(s) || (d2 <= nearDist*nearDist);
      if (!near) continue;
      if (d2 < bestD2){ bestD2=d2; best=s; }
    }
    return best;
  }

  function canOperateLever(s){
    if (!s) return false;
    if (role !== "player") return false;
    const now = performance.now()/1000;
    if (now < s.cooldownUntil) return false;
    if (!touchingGround) return false;
    return true;
  }

  function updateLeverUI(enabled, pullRatio, spring){
    lever.enabled = enabled;
    lever.activeSpring = spring;

    const pct = Math.round(pullRatio*100);
    $("pullFill").style.width = pct + "%";
    $("pullKnob").style.left = pct + "%";
    $("powChip").textContent = pct + "%";

    if (!enabled){
      $("leverBadge").textContent = "OFF";
      $("leverBadge").classList.add("off");
      $("dirChip").textContent = "dir:-";
      $("pullArea").style.opacity = "0.45";
      return;
    }
    $("pullArea").style.opacity = "1";
    $("leverBadge").classList.remove("off");
    $("leverBadge").textContent = lever.dragging ? "CHARGING" : "READY";
    $("dirChip").textContent = spring ? (spring.dir>0 ? "dir:→" : "dir:←") : "dir:-";
  }

  function launchFromSpring(s, pullRatio){
    const now = performance.now()/1000;
    if (now < s.cooldownUntil) return;
    if (!touchingGround) return;

    const maxImpulse = getNum("maxImpulse", 18);
    const cooldown = Math.max(0, getNum("cooldown", 0.30));
    const impulse = (maxImpulse * IMPULSE_MULT) * Math.max(0, Math.min(1, pullRatio));

    Body.setVelocity(coinBody, { x: s.dir * impulse, y: -impulse * UPWARD_BIAS_FIXED });
    Body.setAngularVelocity(coinBody, 0);
    s.cooldownUntil = now + cooldown;

    playSound("shot");
    emitEvent("sound", {key:"shot"});
    shareCoin(true);
    touchAction();
  }

  // Lever input
  $("pullArea").addEventListener("pointerdown", async (e)=>{
    await unlockAudioOnce();
    if (!coinBody) return;

    const s = lever.activeSpring;
    if (!canOperateLever(s)) return;

    lever.dragging = true;
    lever.pointerId = e.pointerId;
    lever.startX = e.clientX;
    lever.currentX = e.clientX;
    $("pullArea").setPointerCapture(e.pointerId);
    touchAction();
  });

  $("pullArea").addEventListener("pointermove", (e)=>{
    if (!lever.dragging) return;
    if (lever.pointerId !== e.pointerId) return;
    lever.currentX = e.clientX;

    const s = lever.activeSpring;
    if (!s) return;

    const maxPull = Math.max(10, getNum("maxPull", 150));
    const dx = lever.currentX - lever.startX;
    const pullSigned = -s.dir * dx;
    const pullPx = Math.max(0, Math.min(maxPull, pullSigned));
    lever.pullRatio = Math.max(0, Math.min(1, pullPx/maxPull));

    updateLeverUI(true, lever.pullRatio, s);
    touchAction();
  });

  $("pullArea").addEventListener("pointerup", (e)=>{
    if (!lever.dragging) return;
    if (lever.pointerId !== e.pointerId) return;

    lever.dragging = false;
    const s = lever.activeSpring;
    const ratio = lever.pullRatio;

    if (s && ratio > 0 && canOperateLever(s)){
      launchFromSpring(s, ratio);
    }
    lever.pullRatio = 0;
    updateLeverUI(lever.enabled, 0, lever.activeSpring);
    touchAction();
  });

  $("pullArea").addEventListener("pointercancel", ()=>{
    lever.dragging=false;
    lever.pullRatio=0;
    updateLeverUI(lever.enabled, 0, lever.activeSpring);
  });

  // --------------------------
  // Share coin state
  // --------------------------
  let lastShareAt = 0;
  function shareCoin(force=false){
    if (role !== "player") return;
    const now = performance.now();
    if (!force && now - lastShareAt < 50) return;
    lastShareAt = now;

    set(PATH.coin, {
      x: coinBody.position.x,
      y: coinBody.position.y,
      vx: coinBody.velocity.x,
      vy: coinBody.velocity.y,
      at: Date.now()
    }).catch(()=>{});
  }

  // clear overlay
  function showClearOverlay10s(){
    const overlay = $("clearOverlay");
    overlay.style.display = "flex";
    setTimeout(()=>{ overlay.style.display="none"; }, 10_000);
  }

  // strong hit sound
  function handleHitSound(ev){
    if (!coinBody) return;
    const now = performance.now();
    if (now - lastHitAt < HIT_COOLDOWN_MS) return;

    for (const pair of ev.pairs){
      const a = pair.bodyA, b = pair.bodyB;
      const coinHit = (a === coinBody || b === coinBody);
      if (!coinHit) continue;
      const other = (a === coinBody) ? b : a;
      if (other.label !== "terrain") continue;

      const v1 = coinBody.velocity;
      const v2 = other.velocity || {x:0,y:0};
      const rel = Math.hypot(v1.x - v2.x, v1.y - v2.y);
      if (rel >= HIT_SPEED_TH){
        lastHitAt = now;
        playSound("hit");
        emitEvent("sound", {key:"hit"});
        break;
      }
    }
  }

  // --------------------------
  // Observe DB state
  // --------------------------
  onValue(PATH.state, (snap)=>{
    const st = snap.exists() ? snap.val() : null;
    const playing = !!(st && st.playing);
    const playerName = (st && st.playerName) ? st.playerName : "-";
    $("playerChip").textContent = `playing: ${playing ? playerName : "-"}`;
    $("btnPlay").disabled = playing;

    if (role === "player"){
      if (!playing || playerName !== yourName){
        setRole("spectator");
      }
    } else {
      setRole("spectator");
    }
  });

  onValue(PATH.events, (snap)=>{
    if (!snap.exists()) return;
    const obj = snap.val();
    const keys = Object.keys(obj);
    keys.sort();
    const lastKey = keys[keys.length - 1];
    const ev = obj[lastKey];
    if (!ev || !ev.type) return;
    if (ev.type === "sound"){
      const k = ev.payload?.key;
      if (k) playSound(k);
    }
  });

  onValue(PATH.coin, (snap)=>{
    if (!snap.exists()) return;
    const c = snap.val();
    if (!coinBody) return;
    if (role === "player") return;
    if (typeof c.x === "number" && typeof c.y === "number"){
      Body.setPosition(coinBody, {x:c.x, y:c.y});
    }
    if (typeof c.vx === "number" && typeof c.vy === "number"){
      Body.setVelocity(coinBody, {x:c.vx, y:c.vy});
    }
  });

  // --------------------------
  // Buttons (player)
  // --------------------------
  $("btnBackReset").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if (role !== "player") return;
    recreateCoin();
  });
  $("btnCoinReset").addEventListener("click", async ()=>{
    await unlockAudioOnce();
    if (role !== "player") return;
    respawnCoin();
  });

  // idle-kill: watch state.lastActionAt (number)
  setInterval(async ()=>{
    const snap = await get(PATH.state);
    if (!snap.exists()) return;
    const st = snap.val();
    if (!st || !st.playing) return;
    const last = typeof st.lastActionAt === "number" ? st.lastActionAt : 0;
    if (!last) return;
    if (Date.now() - last > PLAY_IDLE_TIMEOUT_MS){
      // force release
      await update(PATH.state, { playing:false, playerName:"", lastActionAt: Date.now(), reason:"idle-timeout" });
      if (role === "player") setRole("spectator");
    }
  }, 5000);

  // --------------------------
  // Start game once
  // --------------------------
  async function initGameOnce(){
    if (inited) return;
    inited = true;

    // preload best effort
    loadImage(COIN_IMG_URL).catch(()=>{});
    loadImage(CLEAR_IMG_URL).catch(()=>{});

    const renImg = await loadImage(REN_URL);
    buildRenImageData(renImg);

    engine = Engine.create();
    engine.gravity.y = getNum("gravityY", 1);

    render = Render.create({
      element: $("world"),
      engine,
      options: {
        width: mapW,
        height: mapH,
        wireframes: false,
        background: "#000",
        hasBounds: false,
        pixelRatio: window.devicePixelRatio || 1
      }
    });

    runner = Runner.create();
    Render.run(render);
    Runner.run(runner, engine);

    requestAnimationFrame(resizeCanvasToFit);
    window.addEventListener("resize", resizeCanvasToFit);

    try { await setBackground(MAP_URL); } catch(e){ await setBackground(REN_URL); }

    const {black, red, green, yellow, blue} = buildMasks();

    const greenComps = extractComponents(green, mapW, mapH);
    spawnPoint = (greenComps.length ? greenComps[0].centroid : {x:100,y:100});

    addTerrainFromBlack(black);

    const redComps = extractComponents(red, mapW, mapH);
    const yellowComps = extractComponents(yellow, mapW, mapH);
    const blueComps = extractComponents(blue, mapW, mapH);
    addSensorsFromComponents(redComps, blueComps, yellowComps);

    addCoin();

    Events.on(engine, "collisionStart", (ev)=>handleHitSound(ev));

    Events.on(engine, "collisionActive", (ev)=>{
      touchingGround=false;
      lastGroundNormal=null;

      for (const pair of ev.pairs){
        const A = pair.bodyA, B = pair.bodyB;

        if ((A===coinBody && B.label==="hole") || (B===coinBody && A.label==="hole")){
          if (role === "player"){
            respawnCoin();
            playSound("fail");
            emitEvent("sound", {key:"fail"});
            touchAction();
          }
          continue;
        }

        if ((A===coinBody && B.label==="goal") || (B===coinBody && A.label==="goal")){
          if (role === "player"){
            respawnCoin();
            playSound("clear");
            emitEvent("sound", {key:"clear"});
            showClearOverlay10s();
            touchAction();
          }
          continue;
        }

        const isTerrainContact =
          (A===coinBody && B.label==="terrain") || (B===coinBody && A.label==="terrain");
        if (isTerrainContact){
          touchingGround=true;
          lastGroundNormal = pair.collision.normal;
        }
      }
    });

    Events.on(engine, "afterUpdate", ()=>{
      if (!coinBody) return;

      engine.gravity.y = getNum("gravityY", 1);

      const s = nearestSpringByDistance();
      const enabled = !!s && canOperateLever(s);

      if (!lever.dragging){
        lever.activeSpring = s;
        lever.enabled = enabled;
      } else {
        if (!canOperateLever(lever.activeSpring)){
          lever.dragging=false;
          lever.pullRatio=0;
          lever.enabled=false;
          lever.activeSpring=null;
        }
      }
      updateLeverUI(lever.enabled, lever.pullRatio, lever.activeSpring);

      applySlopeAssist();
      shareCoin(false);

      // admin status
      if (isAdminMode()){
        $("status").textContent =
`map: ${mapW}x${mapH}
role: ${role}
coin: x=${coinBody.position.x.toFixed(1)} y=${coinBody.position.y.toFixed(1)}
vel: vx=${coinBody.velocity.x.toFixed(2)} vy=${coinBody.velocity.y.toFixed(2)} speed=${coinBody.speed.toFixed(2)}
springs: ${springs.length} holes:${holes.length} goals:${goals.length}
impulse: base=${getNum("maxImpulse",18)} x${IMPULSE_MULT} upwardBias=${UPWARD_BIAS_FIXED}
slope: ui=${getNum("slopeAssist",2.0)} x(${SLOPE_ACCEL_MULT}*${SLOPE_EXTRA_MULT}) stuckBoost=${STUCK_BOOST_MULT}`;
      }
    });

    Events.on(render, "afterRender", ()=>{
      drawCoinImage();
      drawYellowFrames();
      if (isAdminMode()) drawAdminOverlays();
    });
  }
</script>
</body>
</html>

